# vim: tw=0:ts=4:sw=4:et:ft=bash

core:import dns
core:import util

function :ldap:host() {
    #. Returns a random LDAP host from the pool
    #. Assumes all hosts are functional

    local -i e=${CODE_FAILURE}

    local user_ldaphost="${USER_LDAPHOSTS[$((${RANDOM}%${#USER_LDAPHOSTS[@]}))]}"
    echo ${user_ldaphost}

    return $e
}
function :ldap:host_rw() {
    #. Returns a random LDAP host from the pool, that offer rw functionality
    #. Assumes all hosts are functional

    local -i e=${CODE_FAILURE}

    local user_ldaphost_rw="${USER_LDAPHOSTS_RW[$((${RANDOM}%${#USER_LDAPHOSTS_RW[@]}))]}"
    echo ${user_ldaphost_rw}

    return $e
}

#. Authentication -={
declare -g g_PASSWD_CACHED=
function :ldap:authenticate() {
    local -i e=${CODE_FAILURE}

    if [ ${#g_PASSWD_CACHED} -eq 0 ]; then
        g_PASSWD_CACHED="$(:util:secrets LDAP)"
        e=$?

        local ldaphost_rw=$(:ldap:host_rw)
        if [ $e -ne 0 ]; then
            read -p "Enter LDAP ($ldaphost_rw}) Password: " -s g_PASSWD_CACHED
            echo
        fi

        ldapsearch -x -LLL -h ${ldaphost_rw} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -b ${USER_UDN} >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            export g_PASSWD_CACHED
            e=${CODE_SUCCESS}
        else
            g_PASSWD_CACHED=
        fi
    else
        e=${CODE_SUCCESS}
    fi
    return $e
}
#. }=-
#. Modification -={
#. LDAP Return Copes
#. 0   - LDAP_SUCCESS
#. 1   - LDAP_OPERATIONS_ERROR
#. 10  - LDAP_REFERRAL
#. 16  - LDAP_NO_SUCH_ATTRIBUTE
#. 19  - LDAP_CONSTRAINT_VIOLATION
#. 20  - LDAP_TYPE_OR_VALUE_EXISTS

function ldap:mkldif:usage() { echo "add|modify|replace|delete user|group <username>/<groupname> <attr1> <val1> [<val2> [...]] [- <attr2> ...]"; }
function ldap:mkldif() {
    local -i e=${CODE_DEFAULT}

    if [ $# -ge 4 ]; then
        ${SITE_LIB_EXTERN}/vimcat <<< "$(::ldap:mkldif $@)" >&2
        e=$?
    fi

    return $e
}
function ::ldap:mkldif() {
: <<!
    This function generates an ldif; which is suitable for feeding into
    ldapmodify.
!
    local -i e=${CODE_FAILURE}

    if [ $# -gt 3 ]; then
        local action=$1
        local context=$2

        local -A changes=(
            [modify]=modify
            [add]=modify
            [replace]=modify
            [delete]=delete
        )
        local change=${changes[${action}]}

        case $context in
            user)
                local username=$3
                echo "# vim:syntax=ldif"
                echo "dn: uid=${username},${USER_UDN}"
                echo "changetype: ${change}"

                local attr=
                for ((i=4; i<$#+1; i++)); do
                    if [ "${!i}" != "-" -a ${#attr} -gt 0 ]; then
                        printf "\n${attr}: ${!i}";
                    else
                        if [ ${#attr} -gt 0 ]; then
                            printf "\n-\n"
                            ((i++))
                        fi
                        attr=${!i}
                        printf "${action}: ${attr}"
                    fi
                done;
                printf "\n "
                e=${CODE_SUCCESS}
            ;;
            group)
                local groupname=$3
                echo "# vim:syntax=ldif"
                echo "dn: cn=${groupname},${USER_GDN}"
                echo "changetype: ${change}"

                local attr=
                for ((i=4; i<$#+1; i++)); do
                    if [ "${!i}" != "-" -a ${#attr} -gt 0 ]; then
                        printf "\n${attr}: ${!i}";
                    else
                        if [ ${#attr} -gt 0 ]; then
                            printf "\n-\n"
                            ((i++))
                        fi
                        attr=${!i}
                        printf "${action}: ${attr}"
                    fi
                done;
                printf "\n "
                e=${CODE_SUCCESS}
            ;;
            *) core:raise EXCEPTION_BAD_FN_CALL;;
        esac
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function :ldap:modify() {
    local -i e=${CODE_FAILURE}

    if [ $# -ge 3 ]; then
        local context=$1
        case ${context} in
            user)
                if :ldap:authenticate; then
                    local username=$2
                    local change=$3
                    case ${change} in
                        delete|add|replace)
                            shift 3
                            local ldif="$(::ldap:mkldif ${change} user ${username} ${@})"
                            local ldaphost_rw=$(:ldap:host_rw)
                            ldapmodify -x -h ${ldaphost_rw} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -c <<< "${ldif}"  >/dev/null 2>&1
                            e=$?
                            if [ $e -ne ${CODE_SUCCESS} ]; then
                                cpf "%{@comment:#. } LDIF %{@err:Failed} with status code %{@int:$e}:\n" >&2
                                ${SITE_LIB_EXTERN}/vimcat <<< "${ldif}" >&2
                            fi
                        ;;
                        *) core:raise EXCEPTION_BAD_FN_CALL INVALID_USER_CHANGE;;
                    esac
                fi
            ;;
            group)
                if :ldap:authenticate; then
                    local groupname=$2
                    local change=$3
                    case ${change} in
                        modify|delete|add|replace)
                            shift 3
                            local ldif="$(::ldap:mkldif ${change} group ${groupname} ${@})"
                            local ldaphost_rw=$(:ldap:host_rw)
                            ldapmodify -x -h ${ldaphost_rw} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -c <<< "${ldif}"  >/dev/null 2>&1
                            e=$?
                            if [ $e -ne ${CODE_SUCCESS} ]; then
                                cpf "%{@comment:#. } LDIF %{@err:Failed} with status code %{@int:$e}:\n" >&2
                                ${SITE_LIB_EXTERN}/vimcat <<< "${ldif}" >&2
                            fi
                        ;;
                        *) core:raise EXCEPTION_BAD_FN_CALL INVALID_GROUP_CHANGE;;
                    esac
                fi
            ;;
            *) core:raise EXCEPTION_BAD_FN_CALL INVALID_CONTEXT;;
        esac
    else
        core:raise EXCEPTION_BAD_FN_CALL INVALID_FN_CALL
    fi

    return $e
}

function :ldap:add() {
: <<!
    This function looks at defined _ldap_* variables and performs an ldapadd
    (ldapmodify -a).
!
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        if :ldap:authenticate; then
            local context=$1
            case $context in
                user)
                    local ldaphost_rw=$(:ldap:host_rw)
                    ldapmodify -a -x -h ${ldaphost_rw} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -f <(
                        echo "dn: uid=${dstuid},${USER_UDN}"
                        unset _ldap_dn
                        for attrs in ${!_ldap_*}; do
                            local -i i
                            #. number of attribute definitions
                            local -i attrlen=$(eval "echo \${#$attrs[@]}")
                            for ((i=0; i<${attrlen}; i++)); do
                                eval 'echo "${attrs//_ldap_/}: ${'$attrs'[${i}]}"' |
                                    sed -e 's/\<'${srcuid}'\>/'${dstuid}'/g'
                            done
                        done
                        echo
                    ) >/dev/null 2>&1
                    e=$?
                ;;
                *) core:raise EXCEPTION_BAD_FN_CALL;;
            esac
        fi
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}
#. }=-
#. Utility -={
function ldap:ngldif:usage() { echo "<host> [<host> [...]]"; }
function ldap:ngldif() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -ge 1 ]; then
        e=${CODE_SUCCESS}
        for host in $@; do
            local -a hsns
            hsns=( $(:dns:qdn ${host} m) )
            if [ $? -eq 0 ]; then
                local hsn
                for hsn in ${hsns[@]}; do
                    echo -e "nisNetgroupTriple: (${hsn//\.*/},,)"
                    echo -e "nisNetgroupTriple: (${hsn}.${USER_TLD},,)"
                    echo -e "nisNetgroupTriple: (${hsn}.${USER_TLD_MGMT},,)"
                done
            else
                e=${CODE_FAILURE}
            fi
        done
    fi

    return $e
}

function ldap:ping:usage() { echo " "; }
function ldap:ping() {
    core:requires ANY colordiff diff

    local -i e=${CODE_DEFAULT}

    if [ $# -eq 0 ]; then
        local -i e=${CODE_SUCCESS}

        local -A sync
        local -A sync_code
        local -A dump
        local md5
        local uidc
        for uidc in {a..z}; do

            cpf "Integrity check for %{c:uid=}%{r:${uidc}*}..."
            local -A md5s=()
            for lh in ${USER_LDAPHOSTS[@]}; do
                dump[${lh}]=$(
                    ldapsearch -x -LLL -E pr=128/noprompt -S dn -h "${lh}" -b "${USER_UDN}"\
                        uid="${uidc}*" ${USER_LDAP_SYNC_ATTRS[@]} |
                            sed -e 's/^dn:.*/\L&/' |
                            grep -v 'pagedresults:' 2>/dev/null
                )
                [ $? -eq 0 ] && cpf '.' || cpf '!'
                md5="$(echo ${dump[${lh}]}|md5sum|awk '{print$1}')"
                md5s[${md5}]=${lh}
            done

            local ldaphost=$(:ldap:host)
            local -i len=$(echo "${dump[${ldaphost}]}"|wc -c)
            if [ ${#md5s[@]} -eq 1 ]; then
                if [ ${len} -gt 1 ]; then
                    theme HAS_PASSED ${md5}:${len}
                else
                    theme HAS_WARNED ${md5}:${len}
                fi
            else
                theme HAS_FAILED "${#md5s[@]} variants in the ${#USER_LDAPHOSTS[@]} hosts"
                e=${CODE_FAILURE}
                for lh in ${USER_LDAPHOSTS[@]}; do
                    if [ ${lh} != ${ldaphost} ]; then
                        cpf "%{@host:${ldaphost}} vs %{@host:${lh}}...\n"
                        #colordiff -y -a \
                        colordiff -T -a -U3 \
                            <(echo "${dump[${ldaphost}]}") \
                            <(echo "${dump[${lh}]}")
                    fi
                done
            fi
        done

    fi

    return $e
}
#. }=-
#. Search -={
function :ldap:eval:search() {
    #. This function searches for a single object
    #.
    #. As all :eval: functions, this function produces code that is to be evaluated by
    #. another bash instance.
    local -i e=${CODE_FAILURE}

    if [ $# -ge 2 ]; then
        local context=$1
        local username=$2
        shift 2
        case $context in
            user)
                local ldaphost=$(:ldap:host)
                local userdata=$(
                    ldapsearch -x -LLL -E pr=1024/noprompt -h "${ldaphost}" -b "${USER_UDN}" "uid=${username}" ${@}|grep -vE ^#
                )
                if [ $# -gt 0 ]; then
                    #. User specified which attrs they want:
                    for attr in $@; do
                        #. evaluate the value of the user-data
                        local r=$(
                            echo "${userdata}" \
                                | grep -Po "^${attr}:\s+.*"\
                                | cut -d' ' -f2\
                                | tr -d '\n'
                        )
                        echo "local _ldap_${attr,,}='${r}';"
                    done
                else
                    #. User asked for a complete dump of the user ldif
                    local -A ldifdata
                    while read line; do
                        local attr="$(echo $line|sed -e 's/^\(.*\): *\(.*\)$/\L\1/')"
                        local val="$(echo $line|sed -e 's/^\(.*\): *\(.*\)$/\2/')"
                        if [ -z "${ldifdata[${attr}]}" ]; then
                            eval "local -a _ldap_${attr,,}=( \"${val}\" )"
                            ((ldifdata[${attr}]=1))
                        else
                            ((ldifdata[${attr}]+=1))
                            eval "_ldap_${attr,,}+=( '${val}' )"
                        fi
                    done <<< "${userdata}"

                    #. Print as eval bash arrays
                    printf "#. WARNING: If ldap values have double-quotes, they will be stripped.\n"
                    for attrs in ${!_ldap_*}; do
                        local -i attrlen=$(eval "echo \${#$attrs[@]}") #. number of attribute definitions

                        printf "local -a ${attrs}=("
                        for ((i=0; i<${attrlen}; i++)); do
                            printf ' "'
                            eval "printf \"\${$attrs[${i}]}\""|tr -d '"'
                            printf '"'
                        done
                        printf " )\n"

                    done

                    #. Print as ldif (bash comments)
                    for attrs in ${!_ldap_*}; do
                        local -i attrlen=$(eval "echo \${#$attrs[@]}") #. number of attribute definitions
                        for ((i=0; i<${attrlen}; i++)); do
                            eval 'echo "#. ${attrs//_ldap_/}: ${'$attrs'[${i}]}"'
                        done
                    done
                fi

                e=${CODE_SUCCESS}
            ;;
        esac
    fi

    return $e
}

function :ldap:search() {
    #. This function seaches for multiple objects
    #.
    #. Usage:
    #.       IFS='|||' read -a fred <<< "$(:ldap:search netgroup cn=jboss_prd nisNetgroupTriple)"

    local -i e=${CODE_FAILURE?}

    if [ $# -gt 1 ]; then
        local bdn
        local ldaphost=$(:ldap:host)

        case $1 in
            user)     bdn=${USER_UDN};;
            group)    bdn=${USER_GDN};;
            netgroup) bdn=${USER_NDN};;
        esac

        if [ ${#bdn} -gt 0 ]; then
            shift 1

            #. Look for filter tokens
            local -a filter
            local -a display
            local token
            for token in $@; do
                if [[ ${token} =~ [-a-zA-Z0-9_]+([~\<\>]?=).+ ]]; then
                    filter+=( "(${token})" )
                else
                    #. Unfortunately, for now it is mandatory that all attributes
                    #. requested must exist, otherwise the caller doesn't know
                    #. which ones are missing.
                    filter+=( "(${token}=*)" )
                    display+=( ${token} )
                fi
            done

            #. 2 for dn_key and dn_value, and 2 for each additional attr key/value pair requested
            local -i awknf=$((2 + 2*${#display[@]}))

            local awkfields='$4'
            for ((i=6; i<=${awknf}; i+=2)); do
                awkfields+=",\"${SITE_DELIM}\",\$$i"
            done

            #. Script-readable dump
            local filterstr="(&$(:util:join '' filter))"
            local -l displaystr=$(:util:join ',' display)
            local querystr="ldapsearch -x -LLL -h '${ldaphost}' -x -b '${bdn}' '${filterstr}' ${display[@]}"
            #cpf "%{@cmd:%s}\n" "${querystr}"

            #. TITLE: echo ${display[@]^^}
            eval ${querystr} | grep -vE '^#' | awk -v displaystr=${displaystr} '
BEGIN{
    FS="\n";
    RS="\n\n";
    split(displaystr,display,",")
}
{
    for(i=1;i<=NF;i++) {
        if($i && $i!~/^#/) {
            match($i, /^([^:]+): +(.*)$/, kv);
            key=tolower(kv[1]);
            value=kv[2];
            if(length(data[key])>0) data[key]=data[key] "|||" value;
            else data[key]=value;
        }
    }

    total=length(display);
    hits=0;
    for(i=1;i<=total;i++) {
        key=display[i];
        if(length(data[key])) hits++;
    }

    if(hits==total) {
        for(i=1;i<=total;i++) {
            if(i>1) printf("'${SITE_DELIM?}'");
            key = display[i];
            printf("%s", data[key]);
        }
        printf("\n");
    }
    delete data;
}'
            e=$?
        fi
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function ldap:search:usage() { echo "<ldap-host> user|group|netgroup <filters>/<show-fields>"; }
function ldap:search() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -gt 1 ]; then
        local bdn
        case $1 in
            user)     bdn=${USER_UDN};;
            group)    bdn=${USER_GDN};;
            netgroup) bdn=${USER_NDN};;
        esac

        if [ ${#bdn} -gt 0 ]; then
            local data=$(:ldap:search $@)
            e=$?

            if [ ${e} -eq ${CODE_SUCCESS} ]; then
                #. Look for filter tokens
                local -a filter
                local -a display
                local token
                for token in ${@:3}; do
                    if [[ ${token} =~ [-a-zA-Z0-9_]+([~\<\>]?=).+ ]]; then
                        filter+=( "(${token})" )
                    else
                        #. Unfortunately, for now it is mandatory that all attributes
                        #. requested must exist, otherwise the caller doesn't know
                        #. which ones are missing.
                        filter+=( "(${token}=*)" )
                        display+=( ${token} )
                    fi
                done

                IFS="${SITE_DELIM}" read ${display[@]} <<< "${data}"

                for attr in ${display[@]}; do
                    local value=${!attr}
                    if [ ${#value} -gt 0 ]; then
                        cpf "%{@key:%-32s}%{@val:%s}\n" "${attr}" "${value}"
                    else
                        cpf "%{@key:%-32s}%{@err:%s}\n" "${attr}" "ERROR"
                        e=${CODE_FAILURE}
                    fi
                done
            fi
        fi
    fi

    if [ ${e} -ne ${CODE_SUCCESS} ]; then
        echo
        cat <<!
Note: if any of the specified attributes are missing, every attribute will
      fail.  This can be fixed, but at relatively great expense as each
      attribute will result in a dedicated ldap query.
!
    fi

    return $e
}
#. }=-
