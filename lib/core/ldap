# vim: tw=0:ts=4:sw=4:et:ft=bash

core:import dns
core:import util

#. Authentication -={
declare -g g_PASSWD_CACHED=
function :ldap:authenticate() {
    local -i e=${CODE_FAILURE}
    if [ ${#g_PASSWD_CACHED} -eq 0 ]; then
        if which secret >/dev/null 2>&1; then
            g_PASSWD_CACHED=$(secret LDAP)
            e=$?
        fi

        if [ $e -ne 0 ]; then
            read -p "Enter LDAP (${USER_LDAPHOST_RW}) Password: " -s g_PASSWD_CACHED
            echo
        fi

        ldapsearch -x -LLL -h ${USER_LDAPHOST_RW} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -b ${USER_UDN} >/dev/null 2>&1
        if [ $? -eq 0 ]; then
            export g_PASSWD_CACHED
            e=${CODE_SUCCESS}
        else
            g_PASSWD_CACHED=
        fi
    else
        e=${CODE_SUCCESS}
    fi
    return $e
}
#. }=-
#. Modification -={
#. LDAP Return Copes
#. 0   - LDAP_SUCCESS
#. 1   - LDAP_OPERATIONS_ERROR
#. 10  - LDAP_REFERRAL
#. 16  - LDAP_NO_SUCH_ATTRIBUTE
#. 19  - LDAP_CONSTRAINT_VIOLATION
#. 20  - LDAP_TYPE_OR_VALUE_EXISTS

function ::ldap:modify() {
    local username=$1
    echo "# vim:syntax=ldif"
    echo "dn: uid=${username},${USER_UDN}"
    echo "changetype: modify"

    local attr=
    for ((i=4; i<$#+1; i++)); do
        if [ "${!i}" != "-" -a ${#attr} -gt 0 ]; then
            printf "\n${attr}: ${!i}";
        else
            if [ ${#attr} -gt 0 ]; then
                printf "\n-\n"
                ((i++))
            fi
            attr=${!i}
            printf "${change}: ${attr}"
        fi
    done;
    printf "\n "
}
function :ldap:modify() {
    local -i e=${CODE_FAILURE}

    if [ $# -ge 2 ]; then
        local context=$1
        case $context in
            user)
                local username=$2
                local change=$3
                if :ldap:authenticate; then
                    case ${change} in
                        delete|add|replace)
                            shift
                            local ldif="$(::ldap:modify ${username} ${@})"
                            ldapmodify -x -h ${USER_LDAPHOST_RW} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -c <<< "${ldif}"  >/dev/null 2>&1
                            e=$?
                            if [ $e -ne ${CODE_SUCCESS} ]; then
                                cpf "%{@comment:#. } LDIF %{@err:Failed} with status code %{@int:$e}:\n" >&2
                                ${SITE_LIB_EXTERN}/vimcat <<< "${ldif}" >&2
                            fi
                        ;;
                        *) core:raise EXCEPTION_BAD_FN_CALL;;
                    esac
                fi
            ;;
            *) core:raise EXCEPTION_BAD_FN_CALL;;
        esac
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function :ldap:add() {
    local -i e=${CODE_FAILURE}

    if [ $# -eq 1 ]; then
        if :ldap:authenticate; then
            local context=$1
            case $context in
                user)
                    ldapadd -x -h ${USER_LDAPHOST_RW} -D "uid=${USER_USERNAME},${USER_UDN}" -w "${g_PASSWD_CACHED}" -f <(
                        echo "dn: uid=${dstuid},${USER_UDN}"
                        unset _ldap_dn
                        for attrs in ${!_ldap_*}; do
                            local -i i
                            local -i attrlen=$(eval "echo \${#$attrs[@]}") #. number of attribute definitions
                            for ((i=0; i<${attrlen}; i++)); do
                                eval 'echo "${attrs//_ldap_/}: ${'$attrs'[${i}]}"' | sed -e 's/\<'${srcuid}'\>/'${dstuid}'/g'
                            done
                        done
                        echo
                    ) >/dev/null 2>&1
                    e=$?
                ;;
                *) core:raise EXCEPTION_BAD_FN_CALL;;
            esac
        fi
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}
#. }=-
#. Utility -={
function ldap:ngldif:usage() { echo "<host> [<host> [...]]"; }
function ldap:ngldif() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -ge 1 ]; then
        e=${CODE_SUCCESS}
        for host in $@; do
            local -a hsns
            hsns=( $(:dns:qdn ${host}) )
            if [ $? -eq 0 ]; then
                local hsn
                for hsn in ${hsns[@]}; do
                    echo -e "nisNetgroupTriple: (${hsn//\.*/},,)"
                    echo -e "nisNetgroupTriple: (${hsn}.${USER_TLD},,)"
                    echo -e "nisNetgroupTriple: (${hsn}.${USER_TLD_MGMT},,)"
                done
            else
                e=${CODE_FAILURE}
            fi
        done
    fi

    return $e
}

function ldap:ping:usage() { echo " "; }
function ldap:ping() {
    core:requires colordiff

    local -i e=${CODE_DEFAULT}

    if [ $# -eq 0 ]; then
        local -i e=${CODE_SUCCESS}

        local -A sync
        local -A sync_code
        local -A dump
        local md5
        local uidc
        for uidc in {a..z}; do

            cpf "Integrity check for %{c:uid=}%{r:${uidc}*}..."
            local -A md5s=()
            for lh in ${USER_LDAPHOSTS[@]}; do
                dump[${lh}]=$( (ldapsearch -x -LLL -E pr=128/noprompt -S dn -h "${lh}" -b "${USER_UDN}" uid="${uidc}*" modifyTimestamp createTimestamp |grep -v 'pagedresults:' 2>/dev/null))
                if [ $? -eq 0 ]; then
                    cpf '.'
                else
                    cpf '!'
                    #core:raise EXCEPTION_UNHANDLED
                fi
                md5="$(echo ${dump[${lh}]}|md5sum|awk '{print$1}')"
                md5s[${md5}]=${lh}
            done

            local -i len=$(echo "${dump[${USER_LDAPHOST}]}"|wc -c)
            if [ ${#md5s[@]} -eq 1 ]; then
                if [ ${len} -gt 1 ]; then
                    theme HAS_PASSED ${md5}:${len}
                else
                    theme HAS_WARNED ${md5}:${len}
                fi
            else
                theme HAS_FAILED "${#md5s[@]} variants in the ${#USER_LDAPHOSTS[@]} hosts"
                e=${CODE_FAILURE}
                for lh in ${USER_LDAPHOSTS[@]}; do
                    if [ ${lh} != ${USER_LDAPHOST} ]; then
                        cpf "%{@host:${USER_LDAPHOST}} vs %{@host:${lh}}...\n"
                        colordiff -a -u\
                            <(echo "${dump[${USER_LDAPHOST}]}") \
                            <(echo "${dump[${lh}]}")
                    fi
                done
            fi
        done

    fi

    return $e
}
#. }=-
#. Search -={
function :ldap:eval:search() {
    #. This function searches for a single object
    #.
    #. As all :eval: functions, this function produces code that is to be evaluated by
    #. another bash instance.
    local -i e=${CODE_FAILURE}

    if [ $# -ge 2 ]; then
        local context=$1
        local username=$2
        shift 2
        case $context in
            user)
                local userdata=$(
                    ldapsearch -x -LLL -E pr=1024/noprompt -h "${USER_LDAPHOST}" -b "${USER_UDN}" "uid=${username}" ${@}
                )
                if [ $# -gt 0 ]; then
                    #. User specified which attrs they want:
                    for attr in $@; do
                        #. evaluate the value of the user-data
                        local r=$(
                            echo "${userdata}" \
                                | grep -Po "^${attr}:\s+.*"\
                                | cut -d' ' -f2\
                                | tr -d '\n'
                        )
                        echo "local _ldap_${attr,,}='${r}';"
                    done
                else
                    #. User asked for a complete dump of the user ldif
                    local -A ldifdata
                    while read line; do
                        local attr="$(echo $line|sed -e 's/^\(.*\): *\(.*\)$/\L\1/')"
                        local val="$(echo $line|sed -e 's/^\(.*\): *\(.*\)$/\2/')"
                        if [ -z "${ldifdata[${attr}]}" ]; then
                            eval "local -a _ldap_${attr,,}=( \"${val}\" )"
                            ((ldifdata[${attr}]=1))
                        else
                            ((ldifdata[${attr}]+=1))
                            eval "_ldap_${attr,,}+=( '${val}' )"
                        fi
                    done <<< "${userdata}"

                    #. Print as eval bash arrays
                    printf "#. WARNING: If ldap values have double-quotes, they will be stripped.\n"
                    for attrs in ${!_ldap_*}; do
                        local -i attrlen=$(eval "echo \${#$attrs[@]}") #. number of attribute definitions

                        printf "local -a ${attrs}=("
                        for ((i=0; i<${attrlen}; i++)); do
                            printf ' "'
                            eval "printf \"\${$attrs[${i}]}\""|tr -d '"'
                            printf '"'
                        done
                        printf " )\n"

                    done

                    #. Print as ldif (bash comments)
                    for attrs in ${!_ldap_*}; do
                        local -i attrlen=$(eval "echo \${#$attrs[@]}") #. number of attribute definitions
                        for ((i=0; i<${attrlen}; i++)); do
                            eval 'echo "#. ${attrs//_ldap_/}: ${'$attrs'[${i}]}"'
                        done
                    done
                fi

                e=${CODE_SUCCESS}
            ;;
        esac
    fi

    return $e
}

function :ldap:search() {
    #. This function seaches for multiple objects
    #.
    #. Usage:
    #.       IFS='|||' read -a fred <<< "$(site ldap search netgroup cn=jboss_prd nisNetgroupTriple)"

    local -i e=${CODE_FAILURE?}

    if [ $# -gt 1 ]; then
        local bdn
        case $1 in
            user)     bdn=${USER_UDN};;
            group)    bdn=${USER_GDN};;
            netgroup) bdn=${USER_NDN};;
        esac

        if [ ${#bdn} -gt 0 ]; then
            shift 1

            local -a filter
            local -a display

            #. Look for filter tokens
            local token
            for token in $@; do
                if [[ ${token} =~ [-a-zA-Z0-9_]+([~\<\>]?=).+ ]]; then
                    filter+=( "(${token})" )
                else
                    filter+=( "(${token}=*)" )
                    display+=( ${token} )
                fi
            done

            #. 2 for dn_key and dn_value, and 2 for each additional attr key/value pair requested
            local -i awknf=$((2 + 2*${#display[@]}))

            local awkfields='$4'
            for ((i=6; i<=${awknf}; i+=2)); do
                awkfields+=",\"+++\",\$$i"
            done

            #. Script-readable dump
            local filterstr="(&$(:util:join '' filter))"
            local -l displaystr=$(:util:join ',' display)
            local querystr="ldapsearch -x -LLL -E pr=1024/noprompt -h '${USER_LDAPHOST}' -x -b '${bdn}' '${filterstr}' ${display[@]}"
            #cpf "%{@cmd:%s}\n" "${querystr}"

            #. TITLE: echo ${display[@]^^}
            eval ${querystr} | awk -v displaystr=${displaystr} '
BEGIN{
    FS="\n";
    RS="\n\n";
    split(displaystr,display,",")
}
{
    for(i=1;i<=NF;i++) {
        if($i && $i!~/^#/) {
            match($i, /^([^:]+): +(.*)$/, kv);
            key=tolower(kv[1]);
            value=kv[2];
            if(length(data[key])>0) data[key]=data[key] "|||" value;
            else data[key]=value;
        }
    }

    if(data[key]) {
        for(i=1; i<=length(display); i++) {
            if(i>1) printf("+++");
            key = display[i];
            printf("%s", data[key]);
        }
        printf("\n");
    }
    delete data;
}'
            e=$?
        fi
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function ldap:search:usage() { echo "user|group|netgroup <filters> <show-fields>"; }
function ldap:search() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -gt 1 ]; then
        local bdn
        case $1 in
            user)     bdn=${USER_UDN};;
            group)    bdn=${USER_GDN};;
            netgroup) bdn=${USER_NDN};;
            *) core:raise EXCEPTION_BAD_FN_CALL;;
        esac

        if [ ${#bdn} -gt 0 ]; then
            :ldap:search $@
            e=${PIPESTATUS[0]}
        fi
    fi

    return $e
}
#. }=-
