# vim: tw=0:ts=4:sw=4:et:ft=bash

#. Unit-test scaffolding -={
#. Pre/post test scaffolding -={
oneTimeSetUp() {
    cpf "%{@comment:#############################################################################}\n"
    cpf "%{@comment:Set-up...}"

    declare -gi tid=0

    declare -g oD="${SHUNIT_TMPDIR}"
    mkdir -p "${oD}"

    declare -g stdoutF="${oD}/stdout"
    declare -g stderrF="${oD}/stderr"

    theme HAS_PASSED
}

oneTimeTearDown() {
    cpf "%{@comment:Tear-down...}"

    rm -rf "${oD?}"

    theme HAS_PASSED
}

setUp() {
    : ${tid?}
    ((tid++))
    cpf "%{@comment:Test} %{y:#${tid}: }"
}

tearDown() {
    :
}
#. }=-
#. Unit-testing coverage test -={
declare -g g_SCRIPT=${SITE_CACHE?}/unittest.sh
function testCoverage() {
    local -i e=0
    local -i t=0
    local -i p=0
    local -i s=0

    :>${g_SCRIPT?}.$$

    local -A fnregexes=(
        [private]='^function ::%s:([a-z0-9_]+:)?[a-z0-9_]+\(\)'
        [internal]='^function :%s:([a-z0-9_]+:)?[a-z0-9_]+\(\)'
        [public]='^function %s:[a-z0-9_]+\(\)'
    )

    echo "#!/bin/bash" >> ${g_SCRIPT?}.$$
    echo "#. Generated at $(date)" >> ${g_SCRIPT?}.$$

    for profile in core ${PROFILE}; do
        if [ -d ${SITE}/lib/${profile} ]; then
            cd ${SITE}/lib/${profile}
            local module
            for module in *; do
                local context
                local blacklisted
                blacklisted="$(awk -F\| "NF==2&&\$1~/^#${profile}$/&&\$2~/^${module}$/{print\"BLACKLISTED\"}" ${SITE_UNITDATA?})"
                if [ "${blacklisted}" != "BLACKLISTED" ]; then
                    cpf "%{@profile:${profile}}: %{!module:${module}} %{r:-=[}\n"
                    for context in ${!fnregexes[@]}; do
                        local regex=$(printf "${fnregexes[${context}]}" ${module})
                        local -i count=$(grep -cE "${regex}" ${module})
                        cpf "    %{!module:${module}}: %{m:${context}}: %{@int:${count}}\n"
                        if [ $count -gt 0 ]; then
                            local -a fns=(
                                $(grep -oE "${regex}" ${module}|sed -e "s/^function :\{0,2\}${module}:\(.*\)()/\1/")
                            )
                            for fn in ${fns[@]}; do
                                local utf="test${profile^}${module^}${fn^}${context^}"
                                utf=${utf/:/} #. Remove the colon for shunit2
                                local -i has_static_test=${FALSE}
                                if [ "$(type -t ${utf})" == 'function' ]; then
                                    cpf "      %{@comment:|___} %{!function:${module}:${fn}}:static %{@fn:${utf}}..."
                                    theme HAS_PASSED "Static"
                                    has_static_test=${TRUE}
                                fi
                                cpf "      %{@comment:|___} %{!function:${module}:${fn}}:dynamic; %{@fn:${utf}}..."
                                blacklisted="$(awk -F\| "\$1~/^#${profile}$/&&\$2~/^${module}$/&&\$3~/^${fn}$/&&\$4~/^${context}$/{print\"BLACKLISTED\"}" ${SITE_UNITDATA?})"
                                if [ "${blacklisted}" != "BLACKLISTED" ]; then
                                    local input
                                    input="$(awk -F\| "\$1~/^${profile}$/&&\$2~/^${module}$/&&\$3~/^${fn}$/&&\$4~/^${context}$/{print\$0}" ${SITE_UNITDATA?})"
                                    if [ -n "${input}" ]; then
                                        local -i i=0
                                        local line
                                        while read line; do
                                            ((i++))
                                            local ffn=
                                            case ${context} in
                                                private)  ffn+=::;;
                                                internal) ffn+=:;;
                                            esac
                                            ffn+=${prefix}${module}:$fn
                                            if [ "${context}" == "public" ]; then
                                                cat <<! >> ${g_SCRIPT}.$$
#. dynamic function ${i} for ${utf} (no-arguments) [ ${profile}:${module}:${fn} ] -={
function ${utf}Dyn${i}NoArgs() {
    #. Check if the function called without any arguments returns CODE_DEFAULT, or otherwise CODE_SUCCESS
    #. TODO: At the moment, no way to tell automatically if its CODE_DEFAULT or CODE_SUCCESS we expect
    #. TODO: so this either/or approach will have to do.
    core:softimport ${module}
    cpf " %{@comment ___site} %{!function:${module}:${fn}} <no-arguments> "
    if assertEquals "import ${module}" ${CODE_SUCCESS} \$?; then
        ${ffn} >/dev/null 2>&1
        ((e=\$? % ${CODE_DEFAULT})) #. See why above
        if assertEquals "exit code" ${CODE_SUCCESS} \${e}; then
            theme HAS_PASSED
        else
            theme HAS_FAILED "Expected return code ${CODE_DEFAULT} or ${CODE_SUCCESS}, but not \${e}"
        fi
    fi
}
!
                                            fi
                                            cat <<! >> ${g_SCRIPT}.$$
function ${utf}Dyn${i}() {
    IFS='|' read profile module fn context stdin arguments stdout stderr exitcode site <<< '${line}'
    : \${exitcode:=-1}

    cpf " %{@comment ___site} %{!function:${module}:${fn}} \${arguments//%/%%} %{r:-=[} "
        cpf "%{g:\${stdout:--}} %{y:/} %{r:\${stderr:--}} %{y:/} ";
        [ \${exitcode} -eq 0 ] && cpf "%{g:0}" || cpf "%{r:\${exitcode}}"
    cpf " %{r:]=-}"

    if [ -z "\${site}" -o "\${site}" == "${PROFILE}" ]; then
        cpf
        core:softimport ${module}
        if assertEquals "import ${module}" ${CODE_SUCCESS} \$?; then
            if assertEquals "function" \$(type -t "${ffn}"); then
                local -i e
                if [ -z "\${stdin}" ]; then
                    ${ffn} \${arguments} >\${stdoutF?} 2>\${stderrF?}
                    e=\$?
                else
                    echo "\${stdin}" | ${ffn} \${arguments} >\${stdoutF?} 2>\${stderrF?}
                    e=\$?
                fi

                if assertEquals "exit code" \${exitcode} \$e; then
                    if [ -n "\${stdout?}" ]; then
                        local stdout_ok=0
                        if [ \${#stdout} -eq 32 ]; then
                            local md5=\$(md5sum \${stdoutF?}|awk '{print\$1}')
                            if [ "\${md5}" == "\${stdout?}" ]; then
                                stdout_ok=1
                            else
                                echo "    \${md5}" vs "\${stdout?}"
                            fi
                        fi
                        if [ \${stdout_ok} -eq 0 ]; then
                            read -r stdout_line <\${stdoutF?}
                            assertEquals "\${stdout?}" "\${stdout_line?}"
                        fi
                    fi

                    if [ -n "\${stderr}" ]; then
                        local stderr_ok=1
                        if [ \${#stderr} -eq 32 ]; then
                            local md5=\$(md5sum \${stderrF}|awk '{print\$1}')
                            if [ "\${md5}" == "\${stderr}" ]; then
                                stderr_ok=1
                            else
                                echo "    \${md5}" vs "\${stdout?}"
                            fi
                        fi
                        if [ \${stderr_ok} -eq 0 ]; then
                            read -r stderr_line <\${stderrF?}
                            if assertEquals "\${stderr?}" "\${stderr_line?}"; then
                                stderr_ok=0
                            else
                                cpf "    %{@warn:WARNING}: Unexpected output to stderr [%{@warn:%s}]\n" "\${stderr}"
                            fi
                        fi
                    fi

                else
                    echo "Exiting early."
                fi
            else
                echo "Exiting early."
            fi
        else
            echo "Exiting early."
        fi
    else
        theme HAS_WARNED "Skipped (\${site})"
    fi
}
#. }=-
!
                                        done <<< "${input}"
                                        theme HAS_PASSED "Dynamic:$i"
                                        ((p++))
                                    else
                                        if [ ${has_static_test} -eq ${TRUE} ]; then
                                            theme HAS_WARNED "Has Static"
                                            ((s++))
                                        else
                                            theme HAS_FAILED "Undefined"
                                            ((e++))
                                        fi
                                    fi
                                else
                                    theme HAS_WARNED "Blacklisted"
                                    ((s++))
                                fi
                                ((t++))
                            done
                        fi
                    done
                    cpf "%{r:]=-} %{@profile:${profile}}: %{!module:${module}}\n"
                else
                    cpf "%{@profile:${profile}}: %{!module:${module}} %{r:-=[} %{@warn:BLACKLISTED} %{r:]=-} %{@profile:${profile}}: %{!module:${module}}\n"
                fi
            done
            cd ${OLDPWD}
            cpf
        fi
    done

    assertEquals "of the $t unit-tests, $p passed, $s skipped, and $e missing; i.e.," $((t-s)) $p
}
#. }=-
#. Unit-test `site' module function -={
function unit:all:usage() { echo "[cache]"; }
function unit:all() {
    local -i e=${CODE_DEFAULT?}
    local cache=0
    local valid=0

    if [ $# -eq 1 -a "$1" == "cache" ]; then
        cache=1
        valid=1
        shift
    elif [ $# -eq 0 ]; then
        valid=1
    fi

    if [ ${valid} -eq 1 ]; then
        if [ -e "${SHUNIT2}" ]; then
            cpf "%{@comment:Part 1 of 2: STATIC unit-testing} %{r:-=[}\n"; (
                SHUNIT_PARENT=${SITE_LIB_CORE}/unit source ${SHUNIT2}
            )
            local -i e1=$?
            if [ ${e1} -eq 0 ]; then
                cpf "%{@comment:exit}:%{g:${e1}} %{r:]=-}\n"
            else
                cpf "%{@comment:exit}:%{r:${e1}} %{r:]=-}\n"
            fi

            cpf "%{@comment:Regenerating CACHE...}"
            if [ ${cache} -eq 1 -a -e ${g_SCRIPT} ]; then
                theme FALSE
            else
                cp ${g_SCRIPT}.$$ ${g_SCRIPT}
                theme TRUE
            fi

            cpf "%{@comment:Part 2 of 2: DYNAMIC unit-testing (${g_SCRIPT})} %{r:-=[}\n"; (
                source ${g_SCRIPT}
                SHUNIT_PARENT=${g_SCRIPT} source ${SHUNIT2}
            )
            local -i e2=$?
            if [ ${e2} -eq 0 ]; then
                cpf "%{@comment:exit}:%{g:${e2}} %{r:]=-}\n"
            else
                cpf "%{@comment:exit}:%{r:${e2}} %{r:]=-}\n"
            fi

            ((e=e1|e2))

            cpf "%{@comment:#############################################################################}\n"
            cpf "Unit-testing overal result..."
            [ $e -eq 0 ] && theme HAS_PASSED || theme HAS_FAILED
        else
            theme ERR_USAGE "${SHUNIT2} is missing"
            e=${CODE_FAILURE}
        fi
    fi

    return $e
}
#. }=-
#. }=-

#. Unit-testing static functions -={
function testCoreHgdResolvePublic() {
    core:softimport hgd
    if assertEquals 0 $?; then
        hgd:resolve '|(#10.1.2.3/29)' >${stdoutF?} 2>${stderrF?}
        if assertEquals 0 $?; then
            for ip in "10.1.2.6" "10.1.2.4" "10.1.2.5" "10.1.2.2" "10.1.2.3" "10.1.2.1"; do
                grep -qE "\<${ip}\>" ${stdoutF}
                assertEquals 0 $?
            done
        fi
    fi
}

function testCoreHgdResolvePrivate() {
    core:softimport hgd
    if assertEquals 0 $?; then
        ::hgd:resolve '&(#10.1.2.3/29)' >${stdoutF?} 2>${stderrF?}
        if assertEquals 0 $?; then
            local so=$(echo -e "#10.1.2.3/29\n10.1.2.1 10.1.2.2 10.1.2.3 10.1.2.4 10.1.2.5 10.1.2.6")
            assertEquals "${so}" "$(cat ${stdoutF})"
        fi
    fi
}

function testPySetsAND() {
    cat <<! | ${SITE_LIBEXEC_CORE}/sets '&(nucky,rothstein,waxy)' >${stdoutF?} 2>${stderrF?}
nucky
aaa
bbb
ccc
ddd

rothstein
bbb
ccc
ddd
eee

waxy
ccc
ddd
eee
fff
!
    if assertEquals 0 $?; then
        assertEquals "ccc ddd" "$(cat ${stdoutF})"
    fi
}

function testPySetsOR() {
    cat <<! | ${SITE_LIBEXEC_CORE}/sets '|(nucky,rothstein,waxy)' >${stdoutF?} 2>${stderrF?}
nucky
aaa
bbb
ccc
ddd

rothstein
bbb
ccc
ddd
eee

waxy
ccc
ddd
eee
fff
!
    if assertEquals 0 $?; then
        assertEquals "aaa bbb eee fff ccc ddd" "$(cat ${stdoutF})"
    fi
}
#. }=-
