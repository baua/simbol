# vim: tw=0:ts=4:sw=4:et:ft=bash

core:import dns
core:import hgd

function :ssh:connect() {
    local -i e=${CODE_FAILURE?}

    local SSH_OPTS='-q -o ConnectionAttempts=1 -o ConnectTimeout=1 -o PasswordAuthentication=no'
    if [ $# -eq 1 ]; then
        ssh -t ${SSH_OPTS} $*
        e=$?
    elif [ $# -ge 2 ]; then
        ssh -T ${SSH_OPTS} $*
        e=$?
    else
        core:raise ${EXCEPTION_BAD_FN_CALL}
    fi

    return $e
}

function ssh:connect:usage() { echo "<hosthint>"; }
function ssh:connect() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -ge 1 ]; then
        if [[ $1 =~ [^\.]+\. ]]; then
            :ssh:connect $*
            e=$?
        elif [ $# -ge 1 ]; then
            core:import dns

            local -a hostnames=( $(:dns:qdn ${1}) )
            local hostname

            if [ ${#hostnames[@]} -gt 0 ]; then
                shift
                if [ ${#hostnames[@]} -gt 1 ]; then
                    cpf WARN "More than one match"
                    for hostname in ${hostnames[@]}; do
                        cpf "    - %{@host:%s}\n" ${hostname}
                    done
                fi
                theme INFO "Connecting to ${hostnames[0]}..."

                :ssh:connect ${hostnames[0]} $*
                e=$?
                if [ $e -eq 255 ]; then
                    theme ERR "Failed to connect to \`${hostnames[0]}'"
                elif [ $e -ne ${CODE_SUCCESS?} ]; then
                    theme WARN "Connection to ${hostnames[0]} terminated with error code \`$e'"
                fi
            elif [ ${#hostnames[@]} -gt 0 ]; then
                for hostname in ${hostnames[@]}; do
                    read record context query sdn ip <<< "$(:dns:lookup P a ${hostname})"
                    printf "$(basename $0) ssh connect %-48s #. %s\n" "${hostname} $*" ${ip}
                done
                e=${CODE_SUCCESS}
            else
                theme ERR "Failed to resolve any host matching \`$1'"
                e=${CODE_FAILURE}
            fi
        fi
    fi

    return $e
}

function ssh:cluster:alert() {
    cat <<!
DEPR This function has been deprecated in favour of tmux.
!
}
function ssh:cluster:usage() { echo "<hosthint> [<hosthint> [...]]"; }
function ssh:cluster() {
    local -i e=${CODE_DEFAULT?}

    core:import hgd

    if [ $# -eq 1 ]; then
        local hgd=$1
        local -a hosts
        hosts=( $(hgd:resolve ${hgd}) )
        if [ $? -eq 0 -a ${#hosts[@]} -gt 0 ]; then
            cssh ${hosts[@]}
        else
            theme ERR_USAGE "That <hgd> did not resolve to any hosts."
            e=${CODE_FAILURE}
        fi
    elif [ $# -gt 1 ]; then
        local -a hostnames
        local hosthint
        for hosthint in $@; do
            hostnames=( ${hostnames[@]} $(:dns:qdn ${hosthint}) )
        done
        cssh ${hostnames[@]}
        e=$?
    fi

    return $e
}

function ::ssh:tmux() {
    local -i e=${CODE_SUCCESS?}

    if [ $# -eq 2 ]; then
        local session=$1
        local hgd=$2

        tmux new-session -d -s "${session}"
        if [ $? -eq 0 ]; then
            local tab
            local -i pid
            local -i lpid
            local -i tid
            local -i otid
            local -a hosts=( $(:hgd:resolve ${hgd}) )
            local -i nodes=${#hosts[@]}

            for ((pid=0; pid<nodes; pid++)); do
                ((lpid=pid%zoning))
                ((otid=tid))
                ((tid=pid/zoning))
                tab="tab-${tid}"
                if [ ${pid} -gt 0 ]; then
                    if [ ${otid} -ne ${tid} ]; then
                        tmux new-window -t "${session}" -a -n "${tab}"
                        tmux select-window -t "${session}:${tab}"
                    fi
                else
                    tmux rename-window -t "${session}:0" "${tab}"
                    tmux select-window -t "${session}:${tab}"
                fi

                [ ${lpid} -eq 0 ] || tmux split-window -h
                cpf "Connection %{g:${tab}}:%{@int:${pid}} to %{@host:${hosts[${pid}]}}..."
                tmux send-keys -t "${lpid}" "ssh ${hosts[${pid}]}; exit $?" C-m
                tmux select-layout -t "${session}:${tab}" tiled >/dev/null
                theme HAS_PASSED "${tab}:${pid}"
            done

            for tid in $(tmux list-windows -t ${session}|awk -F: '{print$1}'); do
                tab="tab-${tid}"
                tmux select-window -t "${session}:${tid}"
                tmux set synchronize-panes on >/dev/null
                tmux select-pane   -t "${session}:${tab}.0"
            done

            tid=0
            pid=0
            tab="tab-${tid}"
            tmux select-window -t "${session}:${tab}"
            tmux select-pane   -t "${session}:${tab}.0"

            tmux attach-session -t "${session}"
            e=$?
        else
            core:raise ${EXCEPTION_BAD_FN_CALL}
        fi
    else
        local -i e=${CODE_FAILURE?}
    fi

    return $e
}

function ssh:tmux:help() {
    cat <<!
    To create a new <tmux-session>, both arguments become mandatory:

        <tmux-session> <hgd:@+>

    Once the <tmux-session> is created however, you can simply connect
    to it without specifying the second argument:

        <tmux-session>

    Finally, you can also opt to use the last form described above if
    you'd like to reference an already created <hgd> session, that
    is the equivalent of specifying two argument with exactly the same
    value.
!
}
function ssh:tmux:usage() { echo "<tmux-session> [<hgd:@+>]"; }
function ssh:tmux() {
    local -i e=${CODE_DEFAULT?}

    core:requires tmux
    core:import hgd

    local -i zoning=12 #. Terminals per tab (tmux window)
    local session=$1
    local hgd=${2:-${session}}

    if [ $# -eq 1 ]; then
        tmux attach-session -t "${session}" 2>/dev/null
        e=$?
        if [ $e -ne 0 ]; then
            if :hgd:list ${hgd} >/dev/null; then
                ::ssh:tmux "${hgd}" "${hgd}"
                e=$?
            else
                theme ERR_USAGE "There is no hgd or tmux session by that name."
            fi
        fi
    elif [ $# -eq 2 ]; then
        if ! tmux has-session -t "${session}" 2>/dev/null; then
            ::ssh:tmux "${session}" "${hgd}"
            e=$?
        else
            theme ERR_USAGE "That session already exists."
            e=${CODE_FAILURE}
        fi
    fi

    return $e
}
