# vim: tw=0:ts=4:sw=4:et:ft=bash

core:import dns
core:import hgd
core:import util

declare -g g_SSH_OPT
g_SSH_OPTS="-q -o ConnectionAttempts=${USER_SSH_ATTEMPTS:-2} -o ConnectTimeout=${USER_SSH_TIMEOUT:-3} -o PasswordAuthentication=no"

function :ssh:copy() {
# FIXME - if fqdn is sent, work out tldid backwards?
    local -i e=${CODE_FAILURE?}

    #.Usage: :ssh:copy ${fqdn}:/etc/security/access.conf ${SITE_CACHE}/${fqdn}-access.conf
    if [ $# -eq 3 ]; then
        local tldid=$1
        local qdn=$2
        shift 2

        local ssh_proxy=${USER_SSH_PROXY[${tldid}]}
        local scp_opts="${g_SSH_OPTS}"
        if [ ${#ssh_proxy} -eq 0 ]; then
            scp ${scp_opts} ${SITE_USERNAME}@${qdn} $*
        else
            #. FIXME: Hardcoding m...
            scp ${scp_opts} -o ProxyCommand="ssh ${SITE_USERNAME}@${ssh_proxy}\
                nc %h.${USER_TLDS[${tldid}]} 22" ${SITE_USERNAME}@${qdn} $*
        fi
    fi

    return $e
}

function :ssh:connect() {
    local -i e=${CODE_FAILURE?}

    if [ $# -ge 2 ]; then
        local tldid=$1
        local hnh=$2
        shift 2

        if [ ${#USER_IFACE[${tldid}]} -gt 0 ]; then
            local -a qdns=( $(:dns:qdn ${tldid} ${hnh}) )
            if [ ${#qdns[@]} -gt 0 ]; then
                local qdn=${qdns[0]}

                local ssh_opts
                if [ $# -eq 0 ]; then
                    #. User wants to ssh into a shell
                    ssh_opts="${g_SSH_OPTS} -t"
                elif [ $# -ge 1 ]; then
                    #. User wants to ssh and execute a command
                    ssh_opts="${g_SSH_OPTS} -T"
                else
                    #. User is confused, and so will we be.
                    core:raise EXCEPTION_BAD_FN_CALL
                fi

                local ssh_proxy=${USER_SSH_PROXY[${tldid}]}
                if [ ${#ssh_proxy} -eq 0 ]; then
                    ssh ${ssh_opts} ${SITE_USERNAME}@${qdn} $*
                    e=$?
                else
                    ssh ${ssh_opts} -o ProxyCommand="ssh ${SITE_USERNAME}@${ssh_proxy}\
                        nc %h.${USER_TLDS[${tldid}]} 22" ${SITE_USERNAME}@${qdn} $*
                    e=$?
                fi
            else
                core:raise EXCEPTION_BAD_FN_CALL "No such host"
            fi
        else
            core:raise EXCEPTION_BAD_FN_CALL "Invalid TLDID"
        fi
    else
        core:raise EXCEPTION_BAD_FN_CALL
    fi

    return $e
}

function :ssh:pipewrap() {
    # This function reads in the input from a terminal and output the same.
    # The only purpose is to insert PASSWORD for "sudo -S" command.
    # After initially insert the password, it simply copy input from terminal
    # and send it to ssh command directly
    echo $1  # which is password
    local lockFile=$2;
    while true; do
        # The function will exit when output pipe is closed,
        if [ ! -e $lockFile ]; then
            return 0
        fi
        # i.e., the ssh
        read -t 1 line
        if [ $? -eq 0 ]; then
            # successfully read
            #echo $line
            : jej
        fi
    done
}

function :ssh:sudo() {
    local -i e=${CODE_FAILURE}

    if [ $# -ge 2 ]; then
        local passwd
        passwd="$(:util:secrets SUDO)"
        if [ $? -eq ${CODE_SUCCESS} ]; then
            local prompt="$(printf ".\r")"
            local lckfile=$(mktemp)

            local hnh=$2
            local tldid
            tldid=$(:dns:qualified ${hnh})
            if [ $? -eq ${CODE_SUCCESS} ]; then
                local fqdn=$2
                shift 2
                :ssh:pipewrap "${passwd}" "${lckfile}" | (
                    :ssh:connect ${tldid} ${fqdn} sudo -p "${prompt}" -S ${*}
                    e=$?
                    rm -f ${lckfile}
                    exit $e
                )
            else
                tldid=$1
                hnh=$2
                shift 2
                :ssh:pipewrap "${passwd}" "${lckfile}" | (
                    :ssh:connect ${tldid} ${hnh} sudo -p "${prompt}" -S ${*}
                    e=$?
                    rm -f ${lckfile}
                    exit $e
                )
            fi

            e=$?
        fi
    fi

    return $e
}

function ssh:sudo:usage() { echo "<tldid> <host-hint> <cmd>"; }
function ssh:sudo() {
    local -i e=${CODE_DEFAULT}

    if [ $# -gt 2 ]; then
        local tldid=$1
        local hnh=$2
        shift 2

        local tld=${USER_TLDS[${tldid}]}
        if [ ${#tld} -gt 0 ]; then
            local -a qdns=( $(:dns:qdn ${tldid} ${hnh}) )
            if [ ${#qdns[@]} -gt 1 ]; then
                cpf WARN "More than one match"
                local qdn
                for qdn in ${qdns[@]}; do
                    cpf "    - %{@host:%s}\n" ${qdn}
                done
            fi
            local qdn=${qdns[0]}

            theme INFO "Connecting to ${qdn}..."
            :ssh:sudo ${tldid} ${hnh} ${*}
            e=$?
        else
            theme ERR "Invalid TLD identifier \'${tldid}'"
            e=${CODE_FAILURE}
        fi
    fi

    return $e
}

function ssh:connect:usage() { echo "<tldid> <hnh>"; }
function ssh:connect() {
    local -i e=${CODE_DEFAULT?}

    if [ $# -ge 2 ]; then
        local hnh=$2
        local tldid
        tldid=$(:dns:qualified ${hnh})
        if [ $? -eq ${CODE_SUCCESS} ]; then
            :ssh:connect $*
            e=$?
        elif [ $# -ge 2 ]; then
            tldid=$1
            shift 2

            local tld=${USER_TLDS[${tldid}]}

            if [ ${#tld} -gt 0 ]; then
                local qdn
                local -a qdns=( $(:dns:qdn ${tldid} ${hnh}) )
                if [ ${#qdns[@]} -gt 0 ]; then
                    if [ ${#qdns[@]} -gt 1 ]; then
                        cpf WARN "More than one match"
                        for qdn in ${qdns[@]}; do
                            cpf "    - %{@host:%s}\n" ${qdn}
                        done
                    fi

                    if [ $# -eq 0 ]; then
                        theme INFO "Connecting to ${qdns[0]} $#..."
                    fi

                    :ssh:connect ${tldid} ${hnh} $*
                    e=$?
                    if [ $e -eq 255 ]; then
                        theme ERR "Failed to connect to \`${qdns[0]}'"
                    elif [ $e -ne ${CODE_SUCCESS?} ]; then
                        theme WARN "Connection to ${qdns[0]} terminated with error code \`$e'"
                    fi
                elif [ ${#qdns[@]} -gt 0 ]; then
                    for qdn in ${qdns[@]}; do
                        read record context query sdn ip <<< "$(:dns:lookup P a ${qdn})"
                        printf "$(basename $0) ssh connect %-48s #. %s\n" "${qdn} $*" ${ip}
                    done
                    e=${CODE_SUCCESS}
                else
                    theme ERR "Failed to resolve any host matching \`${hnh}'"
                    e=${CODE_FAILURE}
                fi
            else
                theme ERR "Invalid TLD identifier \'${tldid}'"
                e=${CODE_FAILURE}
            fi
        fi
    fi

    return $e
}

function ssh:cluster:alert() {
    cat <<!
DEPR This function has been deprecated in favour of tmux.
!
}
function ssh:cluster:usage() { echo "<hnh> [<hnh> [...]]"; }
function ssh:cluster() {
    local -i e=${CODE_DEFAULT?}

    core:import hgd

    local tldid=m

    if [ $# -eq 1 ]; then
        local hgd=$1
        local -a hosts
        hosts=( $(hgd:resolve ${hgd}) )
        if [ $? -eq 0 -a ${#hosts[@]} -gt 0 ]; then
            cssh ${hosts[@]}
        else
            theme ERR_USAGE "That <hgd> did not resolve to any hosts."
            e=${CODE_FAILURE}
        fi
    elif [ $# -gt 1 ]; then
        local -a qdns
        local hnh
        for hnh in $@; do
            qdns=( ${qdns[@]} $(:dns:qdn ${tldid} ${hnh}) )
        done
        cssh ${qdns[@]}
        e=$?
    fi

    return $e
}

function ::ssh:tmux() {
    local -i e=${CODE_SUCCESS?}

    if [ $# -eq 2 ]; then
        local session=$1
        local hgd=$2

        tmux new-session -d -s "${session}"
        if [ $? -eq 0 ]; then
            local tab
            local -i pid
            local -i lpid
            local -i tid
            local -i otid
            local -a hosts=( $(:hgd:resolve ${hgd}) )
            local -i nodes=${#hosts[@]}

            for ((pid=0; pid<nodes; pid++)); do
                ((lpid=pid%zoning))
                ((otid=tid))
                ((tid=pid/zoning))
                tab="tab-${tid}"
                if [ ${pid} -gt 0 ]; then
                    if [ ${otid} -ne ${tid} ]; then
                        tmux new-window -t "${session}" -a -n "${tab}"
                        tmux select-window -t "${session}:${tab}"
                    fi
                else
                    tmux rename-window -t "${session}:0" "${tab}"
                    tmux select-window -t "${session}:${tab}"
                fi

                [ ${lpid} -eq 0 ] || tmux split-window -h
                cpf "Connection %{g:${tab}}:%{@int:${pid}} to %{@host:${hosts[${pid}]}}..."
                tmux send-keys -t "${lpid}" "ssh ${hosts[${pid}]}; exit $?" C-m
                tmux select-layout -t "${session}:${tab}" tiled >/dev/null
                theme HAS_PASSED "${tab}:${pid}"
            done

            for tid in $(tmux list-windows -t ${session}|awk -F: '{print$1}'); do
                tab="tab-${tid}"
                tmux select-window -t "${session}:${tid}"
                tmux set synchronize-panes on >/dev/null
                tmux select-pane   -t "${session}:${tab}.0"
            done

            tid=0
            pid=0
            tab="tab-${tid}"
            tmux select-window -t "${session}:${tab}"
            tmux select-pane   -t "${session}:${tab}.0"

            tmux attach-session -t "${session}"
            e=$?
        else
            core:raise EXCEPTION_BAD_FN_CALL
        fi
    else
        local -i e=${CODE_FAILURE?}
    fi

    return $e
}

function ssh:tmux:help() {
    cat <<!
    To create a new <tmux-session>, both arguments become mandatory:

        <tmux-session> <hgd:@+>

    Once the <tmux-session> is created however, you can simply connect
    to it without specifying the second argument:

        <tmux-session>

    Finally, you can also opt to use the last form described above if
    you'd like to reference an already created <hgd> session, that
    is the equivalent of specifying two argument with exactly the same
    value.
!
}
function ssh:tmux:usage() { echo "<tmux-session> [<hgd:@+>]"; }
function ssh:tmux() {
    local -i e=${CODE_DEFAULT?}

    core:requires tmux
    core:import hgd

    local -i zoning=12 #. Terminals per tab (tmux window)
    local session=$1
    local hgd=${2:-${session}}

    if [ $# -eq 1 ]; then
        tmux attach-session -t "${session}" 2>/dev/null
        e=$?
        if [ $e -ne 0 ]; then
            if :hgd:list ${hgd} >/dev/null; then
                ::ssh:tmux "${hgd}" "${hgd}"
                e=$?
            else
                theme ERR_USAGE "There is no hgd or tmux session by that name."
            fi
        fi
    elif [ $# -eq 2 ]; then
        if ! tmux has-session -t "${session}" 2>/dev/null; then
            ::ssh:tmux "${session}" "${hgd}"
            e=$?
        else
            theme ERR_USAGE "That session already exists."
            e=${CODE_FAILURE}
        fi
    fi

    return $e
}
