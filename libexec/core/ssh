#!/usr/bin/env python
import os, sys, getpass
import paramiko, base64
import binascii, socket, errno
from select import select
from sha import sha
from concurrent import futures

from time import sleep
from random import random

import signal
g_interrupted = False
def signal_handler(signum, frame):
    global g_interrupted
    g_interrupted = True
signal.signal(signal.SIGINT, signal_handler)

import logging
ll = logging.FATAL
logging.basicConfig(level=ll)
#logging.getLogger("paramiko").setLevel(ll)

#class MHKP(paramiko.MissingHostKeyPolicy):
class MHKP(paramiko.AutoAddPolicy):
    def __init__(self, *argv, **kwargs):
        paramiko.AutoAddPolicy.__init__(self, *argv, **kwargs)

    def missing_host_key(self, client, hostname, key):
        client._host_keys.add(hostname, key.get_name(), key) 
        if client._host_keys_filename is not None: 
            client.save_host_keys(client._host_keys_filename) 
        return None

def secret(secret):
    secrets = '%s/.secrets' % os.environ['HOME']
    if os.path.exists(secrets):
        from io import BytesIO
        o = BytesIO()
        with open(secrets, 'r') as ifH:
            from gpgme import Context
            ctx = Context()
            ctx.armor = True
            ctx.decrypt(ifH, o)
        return dict(
            (_.split(None, 1) for _ in o.getvalue().split('\n') if _)
        ).get(secret, '').strip()

class EssEssHache:
    _known_hosts = os.path.expanduser('~/.ssh/known_hosts')

    def __init__(self, threads, timeout):
        self._clients = {}
        self._threads = threads
        self._timeout = timeout

    def add_clients(self, qdns):
        for qdn in qdns:
            client = paramiko.SSHClient()
            client.load_host_keys(self._known_hosts)
            client.set_missing_host_key_policy(MHKP())
            self._clients[qdn] = client

    def del_client(self, qdn):
        client = self._clients.pop(qdn)
        if client._host_keys_filename is not None: 
            client.save_host_keys(client._host_keys_filename) 
        client.close()
        
    def connect(self, username, qdn, command, stdin=[]):
        #sleep(2 * random())

        client = self._clients[qdn]
        data = None
        try:
            data = (qdn, [], [], 1)
            try:
                ssh_proxy = os.environ.get('USER_SSH_PROXY', None)
                tld = os.environ.get('USER_TLD', None)
                #sys.stdout.write("%s=%s\n" % ('ssh_proxy', ssh_proxy))
                #sys.stdout.write("%s=%s\n" % ('tld', tld))

                if ssh_proxy is None:
                    sys.stdout.write("#. queued up %s\n" % qdn)
                    client.connect(qdn, username=username)
                else:
                    sys.stdout.write("#. queued up %s via proxy %s\n" % (qdn, ssh_proxy))
                    proxy_command = paramiko.ProxyCommand(
                        "ssh %s@%s nc %s.%s 22" % (
                            username, ssh_proxy, qdn, tld
                        )
                    )
                    client.connect(qdn, username=username, sock=proxy_command)

                stdout = []
                stderr = []
                ecode = -1

                if stdin:
                    chan = client.get_transport().open_session()
                    _stdin = chan.makefile('wb')
                    _stdout = chan.makefile('rb')
                    _stderr = chan.makefile_stderr('rb')

                    #. If stdout is still open then sudo is asking us for a password
                    if True not in [_stdin.channel.closed, _stdout.channel.closed]:
                        chan.exec_command(command)

                        for line in stdin:
                            _stdin.write("%s\n" % line)
                        _stdin.flush()

                        ecode = chan.recv_exit_status()
                        stdout = _stdout.readlines()
                        stderr = _stderr.readlines()
                    else:
                        estr = "StdinClosedButData"
                        stderr = [estr]
                        stdout = []
                        ecode = 4
                else:
                    _stdin, _stdout, _stderr = client.exec_command(command)
                    ecode = _stdout.channel.recv_exit_status()
                    stdout = _stdout.readlines()
                    stderr = _stderr.readlines()

                data = (qdn, stdout, stderr, ecode)

            except paramiko.BadHostKeyException as exception:
                estr = "BadHostKeyException"
                data = (qdn, [], [estr], 2)

            except paramiko.SSHException as exception:
                estr = "UnknownHost"
                data = (qdn, [], [estr], 2)
                data = (qdn, [], [str(exception)], 2)

            except socket.error as exception:
                if exception.errno == errno.EHOSTUNREACH:
                    estr = "HostUnreacheable"
                    data = (qdn, [], [estr], 3)
                elif exception.errno == errno.ETIMEDOUT:
                    estr = "Timeout"
                    data = (qdn, [], [estr], 3)
                elif exception.errno == errno.ECONNRESET:
                    estr = "Connection Reset"
                    data = (qdn, [], [estr], 3)
                else:
                    estr = "%s: %s" % (exception.__class__, exception)
                    data = (qdn, [], [estr], 7)

            except Exception as exception:
                estr = "%s: %s" % (exception.__class__, exception)
                data = (qdn, [], [estr], 8)

            else:
                self.del_client(qdn)

        except Exception as exception:
            estr = "%s: %s" % (exception.__class__, exception)
            data = (qdn, [], [estr], 9)

        return data


    def writeMeABASHScript(self, var, username, password, cmd):
        with futures.ThreadPoolExecutor(max_workers=self._threads) as executor:
            sys.stdout.write("local -A %s\n" % var)   #. exit code

            #. See if stdin from the shell has any data to offer...
            #stdindata = []
            #if select([sys.stdin,],[],[],0.0)[0]:
            #    stdindata = [_.strip('\n') for _ in sys.stdin.readlines()]

            stdindata = []
            if password:
                cmd = """sudo -S %s""" % cmd
                stdindata.append(password)

            queue = (
                (
                    qdn, executor.submit(
                        self.connect, username, qdn, cmd, stdindata
                    )
                ) for qdn in self._clients.keys()
            )

            sys.stdout.write("local -A %s_o\n" % var) #. stdout
            sys.stdout.write("local -A %s_e\n" % var) #. stderr
            sys.stdout.write("local -A %s_w\n" % var) #. warnings

            i = 0
            total = len(self._clients.keys())
            for qdn, future in queue:
                i += 1
                data = None
                qdn_hash = sha(qdn).hexdigest()
                try:
                    sys.stdout.write(
                        "#. Query with host %s (%d of %d)...\n" % (
                            qdn, i, total
                        )
                    )
                    data = future.result(timeout=self._timeout)
                except futures.TimeoutError:
                    sys.stdout.write("#. %s is taking too long. Oh well.\n" % qdn)
                    #sys.stdout.write("%s[%s]=%d\n" % (var, qdn_hash, 9))
                    #sys.stdout.write("%s_e[%s]='%s'\n" % (var, qdn_hash, 'TIMEOUT'))
                else:
                    qdn, stdout, stderr, e = data

                    sys.stdout.write("%s[%s]=%d\n" % (var, qdn_hash, e))

                    #if len(stdout) == 1:
                    #    if len(stdout[0].strip()) > 0:
                    #        oneline = ''.join(stdout).strip()
                    #        sys.stdout.write("%s_o[%s]='%s'\n" % (var, qdn_hash, oneline))
                    if len(stdout) > 0:
                        sys.stdout.write("read -r -d '' %s_o[%s] <<-!\n" % (var, qdn_hash))
                        sys.stdout.write(''.join(stdout).strip())
                        sys.stdout.write("\n!\n")

                    #if len(stderr) == 1:
                    #    if len(stderr[0].strip()) > 0:
                    #        oneline = ''.join(stderr).strip()
                    #        sys.stdout.write("%s_e[%s]='%s'\n" % (var, qdn_hash, oneline))
                    if len(stderr) > 0:
                        sys.stdout.write("read -r -d '' %s_e[%s] <<-!\n" % (var, qdn_hash))
                        sys.stdout.write(''.join(stderr).strip())
                        sys.stdout.write("\n!\n")

                    #warning = MISSING_HKEY.get(qdn, False);
                    #if warning:
                    #    sys.stdout.write("%s_w[%s]='%s'\n" % (var, qdn_hash, warning))
            sys.stdout.write("#. All done.\n")

def main():
    '''
    Assumptions:

        1. You have ssh public keys in place to connect to remote hosts
        2. If you supply a sudo secret id, you want to wrap the command in sudo
    '''
    e=1

    usage = """
Usage: ssh <threads> <timeout> <var>=<username>[:<sudo-secret-id>]@<host>,<host>,<host>,... <cmd>
"""

    if len(sys.argv) >= 3:
        threads = int(sys.argv[1])
        timeout = int(sys.argv[2])

        var = None
        username = None
        qdns = list()
        cmd = None

        var, remainder = sys.argv[3].split('=', 1)
        password = None
        username, remainder = remainder.split('@', 1)
        if ':' in username:
            username, sid = username.split(':', 1)
            password = secret(sid)

        qdns = remainder.split(',')
        cmd = ' '.join(sys.argv[4:])

        ssh = EssEssHache(threads, timeout)
        ssh.add_clients(qdns)

        ssh.writeMeABASHScript(var, username, password, cmd)

        e=0
    else:
        print(usage)

    return e

if __name__ == '__main__':
    e = 1
    try:
        e = main()
    except KeyboardInterrupt:
        e = 130
    except (IOError, OSError):
        e = 141

    sys.exit(e)
