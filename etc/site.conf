# vim: tw=0:ts=4:sw=4:et:ft=bash

if [ -f ${HOME}/.siterc ]; then
    source ${HOME}/.siterc
fi
: ${PROFILE?}
: ${SITE_USERNAME:=$(whoami)}

HAS_TTY=1
if [ ${SITE_IN_COLOR:-0} -eq 1 ]; then
    HAS_TTY=1
elif [ ! -t 1 ]; then
    HAS_TTY=0
fi

unset CDPATH

export SITE_DELIM=$(printf "\x07")

export SITE=${HOME}/.site
export SITE_ETC=${SITE}/etc/${PROFILE}
export SITE_ETC_CORE=${SITE}/etc/core
export SITE_LIB=${SITE}/lib/${PROFILE}
export SITE_LIB_CORE=${SITE}/lib/core
export SITE_LIB_EXTERN=${SITE}/extern
export SITE_LIBEXEC=${SITE}/libexec/${PROFILE}
export SITE_LIBEXEC_CORE=${SITE}/libexec/core
export SITE_SCM=$(dirname $(dirname $(readlink ~/bin/site)))
export SITE_UNITDATA=${SITE}/share/unittest.csv

export SHUNIT2=${SITE_LIB_EXTERN}/shunit2
export SHFLAGS=${SITE_LIB_EXTERN}/shflags

export PATH=${PATH}:${SITE_LIBEXEC}:${SITE_LIBEXEC_CORE}

export NOW=$(date --utc +%s)
#. FIXME: Mac OS X needs this instead:
#. FIXME: export NOW=$(date -u +%s)

source ${SITE_LIB_CORE}/cpf
source ${SITE_ETC_CORE}/site.conf
[ ${#CORE_MODULES[@]} -ge 1 ] || : ${CORE_MODULES?}

declare -A USER_MODULES
if [ -d ${SITE_ETC} ]; then
    unset USER_MODULES
    source ${SITE_ETC}/site.conf
    [ ${#USER_MODULES[@]} -gt 0 ] || : ${USER_MODULES?}
    : ${USER_TLD?}
    : ${USER_TLD_MGMT?}
    : ${USER_UDN?}
    : ${USER_GDN?}
    : ${USER_NDN?}
fi

source ${SHFLAGS?}
declare SUBNET_CONF=${SITE_ETC?}/subnets.conf
declare SUBNET_FIELDS="name|alloc|comment|dc|gw|dnsz|env|legacy|svcmod|seczone|subnet|vlan"

BASENAME=$(basename $0)
SITE_CACHE=/var/tmp/${BASENAME?}
mkdir -p ${SITE_CACHE?}

#. Exceptions -={
EXCEPTION=63
EXCEPTION_BAD_FN_CALL=64
EXCEPTION_MISSING_EXEC=65
EXCEPTION_BAD_MODULE=66
EXCEPTION_DEPRECATED=67
EXCEPTION_MISSING_PERL_MOD=68
EXCEPTION_MISSING_PYTHON_MOD=69
EXCEPTION_NOT_IMPLEMENTED=126
EXCEPTION_UNHANDLED=127
declare -A RAISE=(
    [${EXCEPTION_BAD_FN_CALL}]="Bad function call internally"
    [${EXCEPTION_MISSING_EXEC}]="Required executable not found"
    [${EXCEPTION_BAD_MODULE}]="Bad module"
    [${EXCEPTION_DEPRECATED}]="Deprecated function call"
    [${EXCEPTION_MISSING_PERL_MOD}]="Required perl module missing"
    [${EXCEPTION_MISSING_PYTHON_MOD}]="Required perl module missing"
)
function core:raise() {
    sleep 0.2
    local -i e=$1

    cpf "%{r}Exception[%{st:%s}]: %s ($*) %{N}\n" ${e} "${RAISE[$e]-[UNKNOWN EXCEPTION:$e]}" 1>&2

    if [ ${#module} -gt 0 ]; then
        if [ ${#fn} -gt 0 ]; then
            cpf "Function %{c:${module}:${fn}()}" 1>&2
        else
            cpf "Module %{c:${module}}" 1>&2
        fi
    else
        cpf "File %{g:$0}" 1>&2
    fi

    cpf " %{r:failed with exception} %{g:$e}; %{c:traceback}:\n" 1>&2
    local i=0
    local -i frames=${#BASH_LINENO[@]}
    #. ((frames-2)): skips main, the last one in arrays
    for ((i=frames-2; i>=0; i--)); do
        cpf "  File %{g:${BASH_SOURCE[i+1]}}, line %{g:${BASH_LINENO[i]}}, in %{r:${FUNCNAME[i+1]}()}\n" 1>&2
        # Grab the source code of the line
        local code=$(sed -n "${BASH_LINENO[i]}{s/^ *//;p}" "${BASH_SOURCE[i+1]}")
        cpf "    %{wh:>>>} %{c}${code}%{N}\n" 1>&2
    done

    exit $e
}
#. }=-
#. Core -={
declare -A SITE_IMPORTED
function core:softimport() {
    local -i e=9
    if [ $# -eq 1 ]; then
        local module=$1
        if [ -z "${SITE_IMPORTED[${module}]}" ]; then
            e=2 #. No such module
            if [ ${USER_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_LIB}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_LIB}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_LIB_CORE}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_LIB_CORE}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 0 -o ${USER_MODULES[${module}]-9} -eq 0 ]; then
                e=${CODE_FAILURE} #. Disabled
            fi
            SITE_IMPORTED[${module}]=$e
        else
            e=${SITE_IMPORTED[${module}]}
        fi
    fi

    return $e
}

function core:import() {
    core:softimport $@
    local -i e=$?
    [ $e -eq 0 ] || core:raise EXCEPTION_BAD_MODULE

    return $e
}

function core:requires() {
    #. Usage examples:
    #.
    #.     core:requires awk
    #.     core:requires perl LWP::Protocol::https
    local -i e=${CODE_SUCCESS}

    case $#:${1} in
        1:*)
            if echo $1|grep -q '/'; then
                if [ ! -e $1 ]; then
                    e=2
                fi
            else
                which $1 > /dev/null 2>&1
                if [ $? -ne 0 ]; then
                    e=${CODE_FAILURE}
                fi
            fi

            if [ $e -ne 0 ]; then
                local caller="${FUNCNAME[1]}"
                local caller_is_mod=$(( ${USER_MODULES[${caller/:*/}]-0} + ${CORE_MODULES[${caller/:*/}]-0} ))
                if [ ${caller_is_mod} -ne 0 ]; then
                    core:raise EXCEPTION_MISSING_EXEC $1
                fi
            fi
        ;;
        2:perl)
            if ! perl -M${2} -e ';' 2>/dev/null; then
                core:raise EXCEPTION_MISSING_PERL_MOD $2
            fi
        ;;
        2:python)
            if ! python -c "import ${2}" 2>/dev/null; then
                core:raise EXCEPTION_MISSING_PYTHON_MOD $2
            fi
        ;;
        *) core:raise EXCEPTION_BAD_FN_CALL $*;;
    esac

    test $e -eq 0 && return $e || exit $e
}

#. Error Codes -={
true
TRUE=$?
CODE_SUCCESS=${TRUE?}

false
FALSE=$?
CODE_FAILURE=${FALSE?}

CODE_ERROR=1               #. 1..63   Errors
CODE_E01=1
CODE_E02=2
CODE_E03=3
CODE_E04=4
CODE_E05=5
CODE_E06=6
CODE_E07=7
CODE_E08=8
CODE_E09=9

CODE_USER_MAX=63           #. 64..127 Internal
CODE_DISABLED=64
CODE_USAGE_SHORT=90
CODE_USAGE_MODS=91
CODE_USAGE_MOD=92
CODE_USAGE_FN_GUESS=93
CODE_USAGE_FN_SHORT=94
CODE_USAGE_FN_LONG=95

CODE_DEFAULT=${CODE_USAGE_FN_LONG?}
#. }=-

function ::core:eval:dereference() {
    #. NOTE: you myst eval the output of this function!
    #. take $1, and make it equal to ${$1}
    #.
    #. If the variable starts with _, remove it in the new variable
    #. Input: _my_var=something; something=( A B C )
    #. Output: my_var=( A B C )
    if [ ! -t 1 ]; then
        echo "unset ${1} && eval \$(declare -p ${!1}|sed -e 's/declare -\([a-qs-zA-Z]*\)r*\([a-qs-zA-Z]*\) ${!1}=\(.*\)/declare -\1\2 ${1}=\3/')";
    else
        core:raise EXCEPTION_BAD_FN_CALL \
            "This function must be called in a subshell, and evaled afterwards!"
    fi
}

function ::core:execute:internal() {
    local module=$1
    local fn=$2
    shift 2
    #set -x
    :${module}:${fn} ${*}
    #set +x
    return $?
}

function ::core:execute:private() {
    local module=$1
    local fn=$2
    shift 2
    #set -x
    ::${module}:${fn} ${*}
    #set +x
    return $?
}

declare -i g_HELP=0
declare -i g_VERBOSE=0
declare g_FORMAT=ansi
declare g_DUMP

function ::core:shflags() {
    local -i e=${CODE_FAILURE}

    #. Extract the first 2 non-flag tokens as module and function
    #. All remaining tokens are addred to the new argv array
    local -a argv
    local -i argc=0
    local module=-
    local fn=-

    local arg
    for arg in $@; do
        if [ ${arg:0:1} != '-' ]; then
            if [ "${module}" == "-" ]; then
                module="${arg?}"
            elif [ "${fn}" == "-" ]; then
                fn="${arg?}"
            else
                argv[${argc}]="${arg?}"
                ((argc++))
            fi
        else
            argv[${argc}]="${arg}"
            ((argc++))
        fi
    done
    set -- ${argv[@]}

    #. Our generic and global optiones
    DEFINE_boolean verbose false "<verbose>" v
    DEFINE_string  format  ascii "ascii|text|csv" f
    DEFINE_boolean help    false "<help>" h

    #. Out module/function-specific options
    local -a extra
    if [ ${#module} -gt 0 ]; then
        core:softimport ${module}
        if [ $? -eq 0 ]; then
            if [ "$(type -t ${module}:${fn}:shflags)" == "function" ]; then
                #. shflags function defined, so let's use it...
                while read f_type f_long f_default f_desc f_short; do
                    DEFINE_${f_type} "${f_long}" "${f_default}" "${f_desc}" "${f_short}"
                    extra+=( FLAGS_${f_long} )
                done < <( ${module}:${fn}:shflags )
            fi
        fi
        cat <<!
declare -g module=${module:-}
declare -g fn=${fn:-}
!
    fi

    #. Process it all
    FLAGS "$@" >/dev/null 2>&1
    if [ $? -eq 0 ]; then
        FLAGS_HELP="site ${module} ${fn} [flags]"
        g_VERBOSE=!${FLAGS_verbose?}; unset FLAGS_verbose
        g_HELP=!${FLAGS_help?}; unset FLAGS_help
        g_FORMAT=${FLAGS_format?}; unset FLAGS_format
        cat <<!
declare -g g_VERBOSE=${g_VERBOSE?}
declare -g g_FORMAT=${g_FORMAT?}
declare -g g_HELP=${g_HELP?}
set -- ${FLAGS_ARGV?}
!
        e=${CODE_SUCCESS}
    else
        g_DUMP=$(FLAGS "$@" 2>&1|sed -e '1,2 d' -e 's/^/    /')
    fi

    cat <<!
$(for key in ${extra[@]}; do echo ${key}=${!key}; done)
!

    return $e
}

function :core:execute() {
    local -i e=${CODE_USAGE_MODS}

    if [ $# -ge 1 ]; then
        e=${CODE_USAGE_MOD}

        if [ $# -ge 2 ]; then
            declare -g module=$1
            declare -g fn=$2
            shift 2

            if [ "$(type -t ${module}:${fn})" == "function" ]; then
                ${module}:${fn} ${*}
                e=$?
                if [ ${HAS_TTY} -eq 1 -a "$(type -t ${module}:${fn}:alert)" == "function" ]; then
                    cpf "%{r:ALERTS}%{bl:@}%{g:${PROFILE}} %{!function:${module} ${fn}}:\n"
                    while read line; do
                        set ${line}
                        local alert=$1
                        shift
                        theme ${alert} "$*"
                    done < <(${module}:${fn}:alert)
                    echo
                fi
            else
                theme ERR_INTERNAL "Function ${module}:${fn} not defined!"
            fi
        fi
    fi

    if [ ${HAS_TTY} -eq 1 -a $e -eq 0 -a ${SECONDS} -ge 30 ]; then
        theme INFO "Execution time was ${SECONDS} seconds"
    fi

    return $e
}

function :core:git() {
    local root=$(dirname $(readlink ~/.site/etc))
    cd ${root}
    git "$@"
    return $?
}

function :core:usage() {
    local module=$1
    local fn=$2
    local mode=${3---short}
    [ $# -eq 2 ] && mode=${3---long}

    if [ ${#FUNCNAME[@]} -lt 4 ]; then
        cpf "%{+bo}%{bl:site}%{-bo} %{@version:%s}, %{wh:the system-administration bash scripting suite}\n" $(:core:git describe "--always")
        cpf "Using %{@path:%s} %{@version:%s}" "${BASH}" "${BASH_VERSION}"
        if [ ${#SITE_SHELL} -eq 0 ]; then
            cpf " %{@comment:(export SITE_SHELL to override)}"
        else
            cpf " %{r:(SITE_SHELL override active)}"
        fi
        printf "\n\n"
    fi

    if [ $# -eq 0 ]; then
        #. Usage for site
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}}\n"
        for profile in USER_MODULES CORE_MODULES; do
            eval $(::core:eval:dereference profile) #. Will create ${profile} array
            for module in ${!profile[@]}; do (
                core:import ${module}
                fns=( $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}') )
                count=${#fns[@]}
                if [ ${count} -gt 0 ]; then
                    cpf "    %{bl:${BASENAME}} %{!module:${module}}:%{@int:%s}\n" "${count}"
                fi
            ); done
        done
    elif [ $# -eq 1 ]; then
        core:import ${module}
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}} %{!module:${module}}\n"
        fns=( $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}') )
        for fn in ${fns[@]}; do
            cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} %{c:%s}\n" "$(${module}:${fn}:usage)"
        done

        if [ ${g_VERBOSE?} -eq 1 -a ${#FUNCNAME[@]} -lt 4 ]; then
            echo
            cpf "%{!module:${module}} %{g:changelog}\n"
            local modfile=${SITE_SCM}/lib/${PROFILE}/${module}
            [ -f ${modfile} ] || modfile=${SITE_SCM}/lib/core/${module}
            cd ${SITE_SCM}
            :core:git --no-pager\
                log --follow --all --format=format:'    |___%C(bold blue)%h%C(reset) %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)'\
                --abbrev-commit --date=relative -- "${modfile}"
            cd ${OLDPWD}
            echo
        fi
        echo
    elif [ $# -ge 2 ]; then
        cpf "%{wh:usage}%{bl:4}%{@user:${SITE_USERNAME}}%{bl:@}%{g:${PROFILE}} %{!function:${module}:${fn}}\n"
        cpf "    %{bl:${BASENAME}} %{!function:${module}:${fn}} "

        case ${mode} in
            --short)
                local usage_s=${module}:${fn}:usage
                cpf "%{c:%s}\n" "[--help|--verbose|--format=(email|ansi)] $(${usage_s})"
                ;;
            --long)
                local usage_s=${module}:${fn}:usage
                cpf "%{c:%s}\n" "[--help|--verbose|--format=(email|ansi)] $(${usage_s})"

                local usage_l=${module}:${fn}:help
                local -i i=0
                if [ "$(type -t $usage_l 2>/dev/null)" == "function" ]; then
                    cpf
                    local indent=""
                    while read line; do
                        cpf "%{c:%s}\n" "${indent}${line}"
                        [ $i -eq 0 ] && indent+="    "
                        ((i++))
                    done <<< "`${usage_l}`"
                fi

                if [ ${#g_DUMP} -gt 0 ]; then
                    cpf
                    cpf "%{c:%s}\n" "flags:"
                    echo "${g_DUMP}"
                fi
            ;;
        esac
    fi
}

function :core:complete() {
    local module=$1
    local fn=$2
    for afn in $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}'); do
        local AC_${module}_${afn}
    done
    local -a completed=( $(eval echo \${!AC_${module}_${fn}*}) )
    if echo ${completed[@]} | grep -qE "\<AC_${module}_${fn}\>"; then
        echo ${fn}
    else
        echo ${completed[@]//AC_${module}_/}
    fi
}

function core:wrapper() {
    local -i e=${CODE_USAGE_MODS}

    local setdata
    setdata="$(::core:shflags $*)"
    local -i e_shflags=$?
    eval "${setdata}"

    local regex=':+[a-z0-9]+(:[a-z0-9]+) |*'
    core:softimport "${module?}"
    case $?/${module?}/${fn?} in
        0/-/-)                                                                                              e=${CODE_USAGE_MODS}       ;;
        0/*/-)               :core:execute          ${module}            2>&1 | grep --color -E "${regex}"; e=${PIPESTATUS[0]};        ;;
        0/*/::*)    set -x; ::core:execute:private  ${module} ${fn:2} $* 2>&1 | grep --color -E "${regex}"; e=${PIPESTATUS[0]}; set +x ;;
        0/*/:*)     set -x; ::core:execute:internal ${module} ${fn:1} $* 2>&1 | grep --color -E "${regex}"; e=${PIPESTATUS[0]}; set +x ;;
        0/*/*)
            local -a completed=( $(:core:complete ${module} ${fn}) )
            if [ ${#completed[@]} -eq 1 ]; then
                fn=${completed}
                if [ ${e_shflags} -eq ${CODE_SUCCESS} ]; then
                    if [ ${g_FORMAT?} == "email" ]; then
                        SITE_IN_COLOR=1 :core:execute ${module} ${completed} $* 2>&1 |
                            grep --color -E "${regex}" |
                            :util:ansi2html |
                            mail -a "Content-type: text/html" -s "Site Report [${module} ${completed} $*]" ${SITE_EMAIL}
                            e=${PIPESTATUS[3]}
                    else
                        :core:execute ${module} ${completed} $*
                        e=$?
                    fi
                else
                    e=${CODE_USAGE_FN_LONG}
                fi
            elif [ ${#completed[@]} -gt 1 ]; then
                theme ERR_USAGE "Did you mean one of the following:"
                for acfn in ${completed[@]}; do
                    echo "    ${BASENAME} ${module} ${acfn}"
                done
                e=${CODE_USAGE_FN_GUESS}
            else
                theme ERR_USAGE "${fn} not defined"
                e=${CODE_USAGE_MOD}
            fi
        ;;
        2/-/-) e=${CODE_USAGE_MODS};;
        2/*/*)
            theme ERR_USAGE "Module ${module} has not been defined"
            e=${CODE_FAILURE}
        ;;
        1/*/*)
            theme ERR_USAGE "Module ${module} has been administratively disabled"
            e=${CODE_DISABLED}
        ;;
        */*/*)
            e=${CODE_FAILURE}
            core:raise EXCEPTION_BAD_FN_CALL "Check call/caller to/of \`core:softimport $*'"
        ;;
    esac

    case $e in
        ${CODE_USAGE_MODS})    :core:usage ;;
        ${CODE_USAGE_SHORT})   :core:usage ${module} ;;
        ${CODE_USAGE_MOD})     :core:usage ${module} ;;
        ${CODE_USAGE_FN_LONG}) :core:usage ${module} ${fn} ;;
        0) : noop;;
    esac

    return $e
}
#. }=-
