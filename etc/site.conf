# vim: tw=0:ts=4:sw=4:et:ft=bash

if [ -f ${HOME}/.siterc ]; then
    source ${HOME}/.siterc
fi
: ${PROFILE?}
: ${SITE_USERNAME:=$(whoami)}

unset CDPATH

export SITE=${HOME}/.site
export SITE_ETC=${SITE}/etc/${PROFILE}
export SITE_ETC_CORE=${SITE}/etc/core
export SITE_LIB=${SITE}/lib/${PROFILE}
export SITE_LIB_CORE=${SITE}/lib/core
export SITE_LIB_EXTERN=${SITE}/extern
export SITE_LIBEXEC=${SITE}/libexec/${PROFILE}
export SITE_LIBEXEC_CORE=${SITE}/libexec/core
export SITE_SCM=$(dirname $(dirname $(readlink ~/bin/site)))
export SITE_UNITDATA=${SITE}/share/unittest.csv

export SHUNIT2=${SITE_LIB_EXTERN}/shunit2
export SHFLAGS=${SITE_LIB_EXTERN}/shflags

export PATH=${PATH}:${SITE_LIBEXEC}:${SITE_LIBEXEC_CORE}

source ${SITE_ETC_CORE}/site.conf
[ ${#CORE_MODULES[@]} -ge 1 ] || : ${CORE_MODULES?}

declare -A USER_MODULES
if [ -d ${SITE_ETC} ]; then
    unset USER_MODULES
    source ${SITE_ETC}/site.conf
    [ ${#USER_MODULES[@]} -gt 0 ] || : ${USER_MODULES?}
    : ${USER_TLD?}
    : ${USER_TLD_MGMT?}
    : ${USER_UDN?}
    : ${USER_GDN?}
    : ${USER_NDN?}
fi

test ! -f ${SHFLAGS} || source ${SHFLAGS}
export SSH_OPTS='-q -T -o ConnectionAttempts=1 -o ConnectTimeout=3 -o PasswordAuthentication=no'
declare SUBNET_CONF=${SITE_ETC}/subnets.conf
declare SUBNET_FIELDS="name|alloc|comment|dc|gw|dnsz|env|legacy|svcmod|seczone|subnet|vlan"

BASENAME=$(basename $0)
SITE_CACHE=/var/tmp/${BASENAME}
mkdir -p ${SITE_CACHE}

#. BASH Utility Functions -={
function core:dereference() {
    #. NOTE: you myst eval the output of this function!
    #. take $1, and make it equal to ${$1}
    #.
    #. If the variable starts with _, remove it in the new variable
    #. Input: _my_var=something; something=( A B C )
    #. Output: my_var=( A B C )
    if [ ! -t 1 ]; then
        echo "unset ${1} && eval \$(declare -p ${!1}|sed -e 's/declare -\([a-qs-zA-Z]*\)r*\([a-qs-zA-Z]*\) ${!1}=\(.*\)/declare -\1\2 ${1}=\3/')";
    else
        c ERR_INTERNAL "This function must be called in a subshell, and evaled afterwards!"
    fi
}

function core:listify() {
    #. Method 1
    IFS=, read -a s <<< "$*"
    echo ${s[@]}

    return

    #. Method 2
    IFS=, read -a s <<< $*
    echo ${s}
}

function core:join() {
    #. array=( a b c ); core:join $delim array
    local IFS=$1
    eval "echo \"\${${2}[*]}\""
}

function core:cphash() {
    assoc_array_string=$(local -p $2)
    eval "local -A $1=${assoc_array_string#*=}"
    echo eval $(local -p $1)
}

function :core:locald() {
    local -pA|awk 'BEGIN{e=1};$0~/local .*'$1'=/{e=0};END{exit(e)}'
    return $?
}
#. }=-
#. Color -={
declare -i ncolors=$(tput colors)
if [ ${ncolors:=-2} -ge 8 ]; then
    #bold="$(tput bold)"
    #underline="$(tput smul)"
    #standout="$(tput smso)"
    #normal="$(tput sgr0)"
    #black="$(tput setaf 0)"
    #red="$(tput setaf 1)"
    #green="$(tput setaf 2)"
    #yellow="$(tput setaf 3)"
    #blue="$(tput setaf 4)"
    #magenta="$(tput setaf 5)"
    #cyan="$(tput setaf 6)"
    #white="$(tput setaf 7)"
    #. http://tldp.org/HOWTO/Bash-Prompt-HOWTO/x405.html
    declare -A COLOR_CODES=(
        [blackf]="\e[30m"   [redf]="\e[31m"
        [greenf]="\e[32m"   [yellowf]="\e[33m"
        [bluef]="\e[34m"    [magentaf]="\e[35m"
        [cyanf]="\e[36m"    [whitef]="\e[37m"

        [blackb]="\e[40m"   [redb]="\e[41m"
        [greenb]="\e[42m"   [yellowb]="\e[43m"
        [blueb]="\e[44m"    [magentab]="\e[45m"
        [cyanb]="\e[46m"    [whiteb]="\e[47m"

        [boldon]="\e[1m"    [boldoff]="\e[22m"
        [italicson]="\e[3m" [italicsoff]="\e[23m"
        [ulon]="\e[4m"      [uloff]="\e[24m"
        [invon]="\e[7m"     [invoff]="\e[27m"

        [reset]="\e[0m"
    )
    #. Keywords
    COLOR_CODES[err]=${COLOR_CODES[redf]}
    COLOR_CODES[crit]=${COLOR_CODES[redf]}
    COLOR_CODES[warn]=${COLOR_CODES[yellowf]}
    COLOR_CODES[info]=${COLOR_CODES[whitef]}
    COLOR_CODES[pass]=${COLOR_CODES[greenf]}
    COLOR_CODES[note]=${COLOR_CODES[greenf]}
    COLOR_CODES[code]=${COLOR_CODES[cyanf]}
    COLOR_CODES[netgroup]=${COLOR_CODES[cyanf]}
    COLOR_CODES[a_netgroup]=${COLOR_CODES[cyanf]}%%
    COLOR_CODES[a_netgroup_direct]=${COLOR_CODES[boldon]}${COLOR_CODES[cyanf]}%%
    COLOR_CODES[a_netgroup_indirect]=${COLOR_CODES[cyanf]}%%
    COLOR_CODES[a_filer]=${COLOR_CODES[magentaf]}
    COLOR_CODES[a_timestamp]=${COLOR_CODES[greenf]}
    COLOR_CODES[a_comment]=${COLOR_CODES[blackf]}#.\ 
    COLOR_CODES[a_hash]=${COLOR_CODES[bluef]}
    COLOR_CODES[a_host]=${COLOR_CODES[boldon]}${COLOR_CODES[bluef]}@
    COLOR_CODES[a_user]=${COLOR_CODES[boldon]}${COLOR_CODES[magentaf]}
    COLOR_CODES[a_int]=${COLOR_CODES[greenf]}
    COLOR_CODES[a_fn]=${COLOR_CODES[cyanf]}
    COLOR_CODES[a_path]=${COLOR_CODES[greenf]}
    COLOR_CODES[a_bad_path]=${COLOR_CODES[redf]}
    COLOR_CODES[a_user]=${COLOR_CODES[yellowf]}
fi

function c() {
    local cmd=$1
    shift 1

    if [ ! -t 1 ]; then
        printf "$@"
    else
        LC_ALL=C
        case ${cmd} in
            [a-z_]*)
                printf "${!cmd-${COLOR_CODES[${cmd}]}}"
                printf "$@"
                printf "${COLOR_CODES[reset]}"
            ;;
            [A-Z_]*)
                case ${cmd} in
                    HAS_FAILED)  printf "${COLOR_CODES[err]}FAIL" ;;
                    HAS_PASSED)  printf "${COLOR_CODES[pass]}PASS" ;;
                    HAS_WARNED)  printf "${COLOR_CODES[warn]}WARN" ;;

                    FALSE)       printf "${COLOR_CODES[err]}FALSE" ;;
                    TRUE)        printf "${COLOR_CODES[pass]}TRUE" ;;

                    ERR)         printf "${COLOR_CODES[err]}Error: " ;;
                    WARN)        printf "${COLOR_CODES[warn]}Warning: " ;;
                    INFO)        printf "${COLOR_CODES[info]}Info: " ;;
                    NOTE)        printf "${COLOR_CODES[note]}Note: " ;;
                    ERR_USAGE)   printf "${COLOR_CODES[redf]}Bad Usage: " ;;

                    TODO)        printf "${COLOR_CODES[warn]}TODO: " ;;
                    FIXME)       printf "${COLOR_CODES[crit]}FIXME: " ;;

                    ERR_EXCEPTION)
                        printf "${COLOR_CODES[redb]}${COLOR_CODES[whitef]}Exception${COLOR_CODES[reset]}: "
                        printf "${COLOR_CODES[redf]}";
                    ;;
                    ERR_INTERNAL)
                        printf "${COLOR_CODES[redb]}${COLOR_CODES[whitef]}Internal error${COLOR_CODES[reset]}: "
                        printf "${COLOR_CODES[redf]}";
                    ;;
                    ALERT)
                        printf "${COLOR_CODES[redb]}${COLOR_CODES[whitef]}Alert${COLOR_CODES[reset]}: "
                        printf "${COLOR_CODES[redf]}";
                    ;;
                esac
                printf "${COLOR_CODES[boldon]}"
                [ $# -eq 0 ] || printf "$*"
                printf "${COLOR_CODES[reset]}\n"
            ;;
        esac
    fi
}

function :core:c:module_is_modified() {
    local -i e=9
    local profile=$1
    local module=$2
    cd ${SITE_SCM}
    if [ -e "${SITE}/lib/${profile}/${module}" ]; then
        local amended=$(git status --porcelain "${SITE}/lib/${profile}/${module}"|wc -l)
        [ ${PIPESTATUS[0]} -ne 0 ] || e=${amended}
    fi
    cd ${OLDPWD}
    return $e
}

function :core:c:module_has_alerts() {
    local -i e=1
    local profile=$1
    local module=$2
    if [ -e "${SITE}/lib/${profile}/${module}" ]; then
        grep -qE "^function ${module}:[a-z0-9]+:alert()" "${SITE}/lib/${profile}/${module}"
        [ $? -ne 0 ] || e=0
    fi
    return $e
}

function ::core:c:function_has_alerts() {
    local -i e=1
    local profile=$1
    local module=$2
    local fn=$3
    if [ -e "${SITE}/lib/${profile}/${module}" ]; then
        grep -qE "^function ${module}:${fn}:alert()" "${SITE}/lib/${profile}/${module}"
        [ $? -ne 0 ] || e=0
    fi
    return $e
}

function :core:c:module() {
    if [ ! -t 1 ]; then
        printf "$@"
    else
        local -r module=$1

        local -i enabled=1
        local -i alerts=0
        local -i amended=0
        local col
        if [ -e ${SITE_LIB_CORE}/${module} ]; then
            if :core:c:module_has_alerts core ${module}; then
                alerts=1
                col=${COLOR_CODES[yellowf]}
            else
                col=${COLOR_CODES[cyanf]}
                :core:c:module_is_modified core ${module}
                amended=$?
            fi
            enabled=${CORE_MODULES[${module}]}
        elif [ -e ${SITE_LIB}/${module} ]; then
            if :core:c:module_has_alerts ${PROFILE} ${module}; then
                alerts=1
                col=${COLOR_CODES[yellowf]}
            else
                col=${COLOR_CODES[bluef]}
                :core:c:module_is_modified ${PROFILE} ${module}
                amended=$?
            fi
            enabled=${USER_MODULES[${module}]}
        fi

        [ ${amended} -eq 0 ] || col+=${COLOR_CODES[ulon]}
        [ ${enabled} -eq 0 ] || col+=${COLOR_CODES[boldon]}
        printf "${col}${module}${COLOR_CODES[reset]}"
    fi
}
function :core:c:function() {
    if [ ! -t 1 ]; then
        printf "$@"
    else
        local -r module=$1
        local -r fn=$2

        local -i enabled=1
        local -i alerts=0
        local -i amended=0
        local col
        if [ -e ${SITE_LIB_CORE}/${module} ]; then
            if ::core:c:function_has_alerts core ${module} ${fn}; then
                alerts=1
                col=${COLOR_CODES[yellowf]}
            else
                col=${COLOR_CODES[cyanf]}
                :core:c:module_is_modified core ${module}
                amended=$?
            fi
            enabled=${CORE_MODULES[${module}]}
        elif [ -e ${SITE_LIB}/${module} ]; then
            if ::core:c:function_has_alerts ${PROFILE} ${module} ${fn}; then
                alerts=1
                col=${COLOR_CODES[yellowf]}
            else
                col=${COLOR_CODES[bluef]}
                :core:c:module_is_modified ${PROFILE} ${module}
                amended=$?
            fi
            enabled=${USER_MODULES[${module}]}
        fi

        [ ${amended} -eq 0 ] || col+=${COLOR_CODES[ulon]}
        [ ${enabled} -eq 0 ] || col+=${COLOR_CODES[boldon]}
        printf "${col}${module} ${COLOR_CODES[bluef]}${fn}${COLOR_CODES[reset]}"
    fi
}

FAIL=$(c redf FAIL)
PASS=$(c greenf PASS)
#. }=-
#. Set Operations -={
function explode() {
    for item in $(eval echo \${$1[@]}); do
        echo ${item}
    done | sort
}

function set_union() {
    sort -um <( explode $1) <(explode $2)
}

function set_intersect() {
    comm -12 <(explode $1) <(explode $2)
}

function set_complement() {
    comm -23 <(explode $1) <(explode $2)
}

function set_symdiff() {
    sd=( $(comm -3 <(explode $1) <(explode $2)) )
    explode sd
}
#. }=-
#. Core -={
declare -A SITE_IMPORTED
function core:softimport() {
    local -i e=9
    if [ $# -eq 1 ]; then
        local module=$1
        if [ -z "${SITE_IMPORTED[${module}]}" ]; then
            e=2 #. No such module
            if [ ${USER_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_LIB}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_LIB}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 1 ]; then
                if [ -f ${SITE_LIB_CORE}/${module} ]; then
                    SITE_IMPORTED[${module}]=0
                    source ${SITE_LIB_CORE}/${module}
                    e=$?
                fi
            elif [ ${CORE_MODULES[${module}]-9} -eq 0 -o ${USER_MODULES[${module}]-9} -eq 0 ]; then
                e=1 #. Disabled
            fi
            SITE_IMPORTED[${module}]=$e
        else
            e=${SITE_IMPORTED[${module}]}
        fi
    fi

    return $e
}

function core:import() {
    core:softimport $@
    local -i e=$?
    [ $e -eq 0 ] || core:raise $e "Failed to import module ${module}"

    return $e
}

function core:requires() {
    local e=0
    if [ $# -eq 1 ]; then
        if echo $1|grep -q '/'; then
            if [ ! -e $1 ]; then
                e=2
            fi
        else
            which $1 > /dev/null 2>&1
            if [ $? -ne 0 ]; then
                e=1
            fi
        fi

        if [ $e -ne 0 ]; then
            local caller="${FUNCNAME[1]}"
            local caller_is_mod=$(( ${USER_MODULES[${caller/:*/}]-0} + ${CORE_MODULES[${caller/:*/}]-0} ))
            if [ ${caller_is_mod} -ne 0 ]; then
                core:raise EXCEPTION_MISSING_EXEC $1
            fi
        fi
    else
        c redf "usage: ${FUNCNAME[0]} <executable>"; echo
        e=3
    fi

    test $e -eq 0 && return $e || exit $e
}

#. Error Codes -={
true
TRUE=$?
CODE_SUCCESS=${TRUE?}

false
FALSE=$?
CODE_FAILURE=${FALSE?}

CODE_ERROR=1               #. 1..63   Errors
CODE_E01=1
CODE_E02=2
CODE_E03=3
CODE_E04=4
CODE_E05=5
CODE_E06=6
CODE_E07=7
CODE_E08=8
CODE_E09=9

CODE_USER_MAX=63           #. 64..127 Internal
CODE_DISABLED=64
CODE_USAGE_HELP=65
CODE_USAGE_SHORT=90
CODE_USAGE_MODS=91
CODE_USAGE_MOD=92
CODE_USAGE_FN_GUESS=93
CODE_USAGE_FN_SHORT=94
CODE_USAGE_FN_LONG=95

CODE_DEFAULT=${CODE_USAGE_FN_LONG?}
#. }=-

function :core:execute() {
    local -i e=${CODE_USAGE_MODS}
    if [ $# -ge 1 ]; then
        e=${CODE_USAGE_MOD}
        if [ $# -ge 2 ]; then
            local module=$1
            local fn=$2
            shift 2

            if [ "$(type -t ${module}:${fn})" == "function" ]; then
                if [ "$(type -t ${module}:${fn}:shflags)" == "function" ]; then
                    #. shflags function defined, so let's use it...
                    while read f_type f_long f_default f_desc f_short; do
                        DEFINE_${f_type} "${f_long}" "${f_default}" "${f_desc}" "${f_short}"
                    done < <( ${module}:${fn}:shflags )
                    FLAGS "$@"
                    e=$?
                    if [ $e -eq 0 ]; then
                        eval set -- "${FLAGS_ARGV}"
                        ${module}:${fn} ${*}
                        e=$?
                    fi
                else
                    #. No shflags, so let's just run with it...
                    ${module}:${fn} ${*}
                    e=$?
                fi

                if [ -t 1 -a "$(type -t ${module}:${fn}:alert)" == "function" ]; then
                    echo
                    c redf "ALERTS"; c blackf '@'; c greenf "${PROFILE}"; c white ' ';
                    :core:c:module "${module}"; c whitef '.'; c cyanf "${fn}()"; echo :
                    while read line; do
                        printf "    "
                        c $line
                    done < <(${module}:${fn}:alert)
                    echo
                fi
            else
                c ERR_INTERNAL "Function ${module}:${fn} not defined!"
            fi
        fi
    fi
    if [ -t 1 -a $e -eq 0 -a ${SECONDS} -ge 30 ]; then
        c greenf "Execution time: %d seconds" ${SECONDS}; echo
    fi
    return $e
}

function :core:help() {
    local profile
    for profile in USER_MODULES CORE_MODULES; do
        eval $(core:dereference profile) #. Will create ${profile}
        local module
        for module in ${!profile[@]}; do
            :core:usage ${module}
        done
        echo
    done
}

function :core:usage() {
    local module=$1
    local fn=$2
    local mode=${3---short}
    [ $# -eq 2 ] && mode=${3---long}

    if [ $# -eq 0 ]; then
        c whitef "usage"; c blackf '4'; c a_user "${SITE_USERNAME}"; c blackf '@'; c greenf "${PROFILE}"; echo :
        c blackf "    %s " "${BASENAME}"
        for profile in USER_MODULES CORE_MODULES; do
            eval $(core:dereference profile) #. Will create ${profile}
            for module in ${!profile[@]}; do
                :core:c:module ${module}
                c whitef '|'
            done
        done
        echo help
    elif [ $# -eq 1 ]; then
        core:import ${module}
        c whitef "usage"; c blackf '4'; c a_user "${SITE_USERNAME}"; c blackf '@'; c greenf "${PROFILE}"; c white ' ';
        :core:c:module "${module}"; echo :
        fns=( $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}') )
        for fn in ${fns[@]}; do
            c blackf "    %s " "${BASENAME}"
            :core:c:function "${module}" "${fn}"

            usage_s=${module}:${fn}:usage
            c cyanf ' %s\n' "$(${usage_s})"
        done

        printf "    "
        :core:c:module "${module}"
        c greenf ' changelog'; echo :
        local modfile=${SITE_SCM}/lib/${PROFILE}/${module}
        [ -f ${modfile} ] || modfile=${SITE_SCM}/lib/core/${module}
        cd ${SITE_SCM}
        git --no-pager\
            log --follow --all --format=format:'    \___%C(bold blue)%h%C(reset) %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)'\
            --abbrev-commit --date=relative -- "${modfile}"
        cd ${OLDPWD}
        echo
        echo
    elif [ $# -ge 2 ]; then
        c whitef "usage"; c blackf '4'; c a_user "${SITE_USERNAME}"; c blackf '@'; c greenf "${PROFILE}"; c white ' ';
        :core:c:module "${module}"; c whitef '.'; c cyanf "${fn}()"; echo :
        c blackf "    %s " "${BASENAME}"
        :core:c:function "${module}" "${fn}"

        case ${mode} in
            --short)
                usage_s=${module}:${fn}:usage
                c cyanf ' %s\n' "$(${usage_s})"
                ;;
            --long)
                usage_s=${module}:${fn}:usage
                usage_l=${module}:${fn}:help
                if [ "$(type -t $usage_l 2>/dev/null)" == "function" ]; then
                    echo
                    c cyanf ' %s' "$(${usage_l})"; echo
                elif [ "$(type -t $usage_s 2>/dev/null)" == "function" ]; then
                    c cyanf ' %s' "$(${usage_s})"; echo
                else
                    echo
                fi
            ;;
        esac
    fi
}

function :core:complete() {
    local module=$1
    local fn=$2
    for afn in $(declare -F|awk -F'[ :]' '$3~/'${module}'/&&$5~/^usage$/{print$4}'); do
        local AC_${module}_${afn}
    done
    local -a completed=( $(eval echo \${!AC_${module}_${fn}*}) )
    echo ${completed[@]//AC_${module}_/}
}

EXCEPTION=63
EXCEPTION_BAD_FN_CALL=64
EXCEPTION_MISSING_EXEC=65
declare -A RAISE=(
    [${EXCEPTION_BAD_FN_CALL}]="Bad function call internally"
    [${EXCEPTION_MISSING_EXEC}]="Required executable not found"
)
function core:raise() {
    local -i e=$1

    if [ $e -ne 0 ]; then
        c ERR_EXCEPTION "${RAISE[$e]-[UNDOCUMENTED EXCEPTION CODE:$e]}"
        shift; [ $# -eq 0 ] || printf " * "; c ERR $*; echo

        c code "${module}:${fn}()";
        c redf " failed with exception $e; traceback:"; echo
        local i=0
        local -i frames=${#BASH_LINENO[@]}
        #. ((frames-2)): skips main, the last one in arrays
        for ((i=frames-2; i>=0; i--)); do
            printf '  File "'; c a_path "${BASH_SOURCE[i+1]}"; printf '"'
            printf ', line '; c a_int "${BASH_LINENO[i]}"
            printf ', in '; c a_fn "${FUNCNAME[i+1]}()"
            echo
            # Grab the source code of the line
            local code=$(sed -n "${BASH_LINENO[i]}{s/^ *//;p}" "${BASH_SOURCE[i+1]}")
            c cyanf "    >>> ${code}"; echo
        done

        exit $e
    fi

    return $e
}

function core:wrapper() {
    local -i e=${CODE_USAGE_MODS}
    local module=${1}
    local fn=
    if [ -n "${module}" -a "${module}" != "help" ]; then
        core:softimport ${module}
        local -i ie=$?
        case $ie in
            0)
                fn=${2}
                if [ -n "${fn}" ]; then
                    local -a completed=( $(:core:complete ${module} ${fn}) )
                    if [ ${#completed[@]} -eq 1 ]; then
                        shift 2
                        fn=${completed}
                        :core:execute ${module} ${completed} $*
                        e=$?
                    elif [ $# -ge 2 -a ${#completed[@]} -gt 1 ]; then
                        c redf "Error: Did you mean one of the following:"; echo
                        for acfn in ${completed[@]}; do
                            echo "    ${BASENAME} ${module} ${acfn}"
                        done
                        e=${CODE_USAGE_FN_GUESS}
                    else
                        e=${CODE_USAGE_MOD}
                    fi
                elif [ $# -eq 1 ]; then
                    e=${CODE_USAGE_MOD}
                else
                    :core:execute $*
                    e=$?
                fi
            ;;
            1)
                c redf "Error: Module ${module} has been administratively disabled"; echo
                e=${CODE_DISABLED}
            ;;
            2)
                c redf "Error: Module ${module} has not been defined."; echo
                e=1
            ;;
        esac
    elif [ "${module}" == "help" ]; then
        e=${CODE_USAGE_HELP}
    else
        e=${CODE_USAGE_MODS}
    fi

    case $e in
        ${CODE_USAGE_HELP})    :core:help ;;
        ${CODE_USAGE_MODS})    :core:usage ;;
        ${CODE_USAGE_SHORT})   :core:usage ${module} ;;
        ${CODE_USAGE_MOD})     :core:usage ${module} ;;
        ${CODE_USAGE_FN_LONG}) :core:usage ${module} ${fn} ;;
        0) : noop;;
    esac

    return $e
}
#. }=-
